var documenterSearchIndex = {"docs":
[{"location":"tutorials/index.html#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"If you want to know how Snowflake is used, this is the place to be. The tutorials are the best place to start if you are new to quantum computation. These tutorials take you step by step through Snowflake, gradually introduce concepts and assume no prior quantum computation knowledge. We recommend you work through these tutorials in order to get the most out of them.","category":"page"},{"location":"tutorials/index.html#Basic-Concepts","page":"Tutorial","title":"Basic Concepts","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we introduce basic concepts and objects that are used in Snowflake.","category":"page"},{"location":"tutorials/index.html#Get-QPU-metadata","page":"Tutorial","title":"Get QPU metadata","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we introduce the QPU interface and how to get the metadata of the machine.","category":"page"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"Tutorial: Get QPU metadata tutorial Code: tutorials/get_qpu_metadata.jl","category":"page"},{"location":"tutorials/index.html#Single-qubit-readout-fidelity","page":"Tutorial","title":"Single-qubit readout fidelity","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we cover the basics of initialization, readout, and readout fidelity.","category":"page"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"Tutorial: Single-qubit readout tutorial Code: tutorials/single_qubit_readout_fidelity.jl","category":"page"},{"location":"tutorials/index.html#Excitation-demonstration","page":"Tutorial","title":"Excitation demonstration","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we excite the qubit into state one.","category":"page"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"Tutorial: Excitation demonstration Code: tutorials/excitation_demonstration.jl","category":"page"},{"location":"tutorials/index.html#Hadamard-transpilation","page":"Tutorial","title":"Hadamard transpilation","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we introduce the hadamard gate and circuit transpilation.","category":"page"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"Tutorial: Hadamard transpilation tutorial Code: tutorials/hadamard_transplation.jl","category":"page"},{"location":"tutorials/index.html#Entanglement-demonstration","page":"Tutorial","title":"Entanglement demonstration","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we demonstrate entanglement by generating a Bell state.","category":"page"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"Tutorial: Entanglement demonstration tutorial Code: tutorials/entanglement_demonstration.jl","category":"page"},{"location":"tutorials/index.html#Asyncronous-jobs","page":"Tutorial","title":"Asyncronous jobs","text":"","category":"section"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we show how to run jobs asynchronously using Julia tasks.","category":"page"},{"location":"tutorials/index.html","page":"Tutorial","title":"Tutorial","text":"Tutorial: asynchronous jobs Code: tutorials/asynchronous_jobsjl","category":"page"},{"location":"getting_started.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"DocTestSetup = quote\n    ENV[\"ANYON_QUANTUM_USER\"] = \"test-user\"\n    ENV[\"ANYON_QUANTUM_TOKEN\"] = \"not-a-real-token\"\n    ENV[\"ANYON_QUANTUM_HOST\"] = \"yukon.anyonsys.com\"\nend","category":"page"},{"location":"getting_started.html#Typical-workflow","page":"Getting Started","title":"Typical workflow","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"A typical workflow to execute a quantum circuit on a quantum service consists of these three steps.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Create: Build the circuit using quantum gates.\nTranspile: Transpile the circuit to improve performance and make the circuit compatible with the quantum service.\nExecute: Run the compiled circuits on the specified quantum service. The quantum service could be a remote quantum hardware or a local simulator.","category":"page"},{"location":"getting_started.html#Create-a-Circuit","page":"Getting Started","title":"Create a Circuit","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Now, let's try Qanuk by making a two-qubit circuit which implements a Bell/EPR state. The quantum circuit for generating a Bell state involves a Hadamard gate on one of the qubits followed by a CNOT gate (see https://en.wikipedia.org/wiki/Quantumlogicgate for an introduction to quantum logic gates). This circuit is shown below:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"<div style=\"text-align: center;\">\n\t<img\n\t\tsrc=\"./images/bell_circuit.svg\"\n\t\ttitle=\"Bell state generator circuit\"\n\t\twidth=\"240\"\n\t/>\n</div>","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"First import Qanuk:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"using Qanuk","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"With Qanuk imported, we can define our two-qubit circuit.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"c = QuantumCircuit(qubit_count=2)\nprint(c)\n\n# output\n\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:\n\nq[2]:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"In Qanuk, all qubits start in state left0rightrangle. Our circuit is, therefore, in state left00rightrangle. We now proceed by adding gates to our circuit.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"push!(c, hadamard(1), control_x(1, 2))\nprint(c)\n\n# output\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──H────*──\n            |\nq[2]:───────X──","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The first line adds a Hadamard gate to circuit object c which will operate on qubit 1. The second line adds a CNOT gate (Control-X gate) with qubit 1 as the control qubit and qubit 2 as the target qubit.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"note: Note\nUnlike C++ or Python, indexing in Julia starts from \"1\" and not \"0\"!","category":"page"},{"location":"getting_started.html#Simulate-your-circuit","page":"Getting Started","title":"Simulate your circuit","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The next step we want to take is to simulate our circuit. We do not need to transpile our circuit since our simulator can handle all gates, but for larger circuit you should consider transpilation to reduce the amount of work the simulator has to perform.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"ψ = simulate(c)\nprint(ψ)\n\n# output\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Finally, you can use SnowflakePlots to generate a histogram which shows the measurement output distribution after taking a certain number of shots, in this case 100, on a quantum computer simulator:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"using SnowflakePlots\nplot_histogram(c, 100)","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"(Image: Measurement results histogram)","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The script below puts all the steps above together:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"using Qanuk, SnowflakePlots\n\nc = QuantumCircuit(qubit_count=2)\npush!(c, [hadamard(1)])\npush!(c, [control_x(1, 2)])\n\nψ = simulate(c)\n\nplot_histogram(ψ, 100)","category":"page"},{"location":"getting_started.html#Execute-on-Anyon's-hardware","page":"Getting Started","title":"Execute on Anyon's hardware","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Let's see how how to run the circuit created in the previous section on real hardware. At ","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We want to interact with Anyon's Quantum Computers, so we are going to construct an AnyonQPU. Three things are needed to construct an AnyonQPU. We need the username and access token to authenticate with the quantum computer and the hostname where the quantum computer can be found. The easiest way to get these parameters is by reading them from environment variables. For more information on QPU objects please go to the Get QPU Metadata tutorial.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"user = ENV[\"ANYON_QUANTUM_USER\"]\ntoken = ENV[\"ANYON_QUANTUM_TOKEN\"]\nhost = ENV[\"ANYON_QUANTUM_HOST\"]\n\nqpu = AnyonQPU(host=host, user=user, access_token=token)\nprint(qpu)\n\n# output\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   qubit_count:   6\n   connectivity_type:  linear","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We can now run our circuit with","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"num_repetitions = 200\nresult = transpile_and_run_job(qpu, circuit, num_repetitions)","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"and plot the results with","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"plot_histogram(result)","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"(Image: Measurement results histogram)","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The script below puts all the steps above together:","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"using Qanuk, SnowflakePlots\n\nuser = ENV[\"ANYON_QUANTUM_USER\"]\ntoken = ENV[\"ANYON_QUANTUM_TOKEN\"]\nhost = ENV[\"ANYON_QUANTUM_HOST\"]\n\nqpu = AnyonQPU(host=host, user=user, access_token=token)\n\ncircuit = QuantumCircuit(qubit_count=2)\npush!(circuit, [hadamard(1)])\npush!(circuit, [control_x(1, 2)])\n\nnum_repetitions = 200\nresult = transpile_and_run_job(qpu, circuit, num_repetitions)\n\nplot_histogram(result)","category":"page"},{"location":"getting_started.html#More-information","page":"Getting Started","title":"More information","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"For more information head over to our Tutorials page or our Library reference page.","category":"page"},{"location":"library.html#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"DocTestSetup = :(using Qanuk, QanukPlots)","category":"page"},{"location":"library.html#Quantum-Circuit","page":"Library","title":"Quantum Circuit","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"QuantumCircuit\npush!\npop!\nappend!\nprepend!\nsimulate\nsimulate_shots\nget_measurement_probabilities(circuit::QuantumCircuit)\ninv(circuit::QuantumCircuit)\nget_num_gates_per_type\nget_num_gates\nserialize_job\ntranspile\ncompare_circuits\ncircuit_contains_gate_type\npermute_qubits!\npermute_qubits","category":"page"},{"location":"library.html#Qanuk.QuantumCircuit","page":"Library","title":"Qanuk.QuantumCircuit","text":"QuantumCircuit(qubit_count)\n\nA data structure to represent a quantum circuit.  \n\nFields\n\nqubit_count::Int – number of qubits (i.e. quantum register size).\ngates::Vector{AbstractGate} – the sequence of gates to operate on qubits.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n\n\n\n\n\n","category":"type"},{"location":"library.html#Base.push!","page":"Library","title":"Base.push!","text":"push!(circuit::QuantumCircuit, gates::AbstractGate...)\n\nInserts one or more gates at the end of a circuit.\n\nA Vector of AbstractGate objects can be passed to this function by using splatting. More details about splatting are provided here.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────X────X──\n                    \n\n\n\njulia> gate_list = [sigma_x(1), hadamard(2)];\n\njulia> push!(c, gate_list...)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*────X───────\n                 |            \nq[2]:───────X────X─────────H──\n                              \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.pop!","page":"Library","title":"Base.pop!","text":"pop!(circuit::QuantumCircuit)\n\nRemoves the last gate from circuit.gates. \n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────X────X──\n                    \n\n\n\njulia> pop!(c)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.append!","page":"Library","title":"Base.append!","text":"append!(base_circuit::QuantumCircuit, circuits_to_append::QuantumCircuit...)\n\nAppends one or more circuits_to_append to the base_circuit.\n\nThe circuits_to_append cannot contain more qubits than the base_circuit.\n\nExamples\n\njulia> base = QuantumCircuit(qubit_count=2, gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> append_1 = QuantumCircuit(qubit_count=1, gates=[sigma_z(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──Z──\n          \n\n\n\njulia> append_2 = QuantumCircuit(qubit_count=2, gates=[control_x(1,2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──X──\n          \n\n\n\njulia> append!(base, append_1, append_2)\n\njulia> print(base)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X────Z────*──\n                 |  \nq[2]:────────────X──\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.prepend!","page":"Library","title":"Base.prepend!","text":"prepend!(base_circuit::QuantumCircuit, circuits_to_prepend::QuantumCircuit...)\n\nPrepends one or more circuits_to_prepend to the base_circuit.\n\nThe order of the circuits_to_prepend is maintained (i.e. circuits_to_prepend[1] will appear leftmost in base_circuit). The circuits_to_prepend cannot contain more qubits than the base_circuit.\n\nExamples\n\njulia> base = QuantumCircuit(qubit_count=2, gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> prepend_1 = QuantumCircuit(qubit_count=1, gates=[sigma_z(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──Z──\n          \n\n\n\njulia> prepend_2 = QuantumCircuit(qubit_count=2, gates=[control_x(1,2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──*──\n       |  \nq[2]:──X──\n          \n\n\n\njulia> prepend!(base, prepend_1, prepend_2)\n\njulia> print(base)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────*────X──\n            |       \nq[2]:───────X───────\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.simulate","page":"Library","title":"Qanuk.simulate","text":"simulate(circuit::QuantumCircuit)\n\nSimulates and returns the wavefunction of the quantum device after running circuit,  assuming an initial state Ket ψ corresponding to the 0th Fock basis, i.e.:  ψ=fock(0,2^get_num_qubits(circuit)). \n\nEmploys the approach described in Listing 5 of Suzuki et. al. (2021).\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n          \n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               \n\n\njulia> ket = simulate(c)\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.simulate_shots","page":"Library","title":"Qanuk.simulate_shots","text":"simulate_shots(c::QuantumCircuit, shots_count::Int = 100)\n\nEmulates a quantum computer by running a circuit for a given number of shots and returning measurement results.  The distribution of measured states corresponds to the coefficients in the resulting state Ket. \n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2);\n\njulia> push!(c, hadamard(1))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n          \n\n\njulia> push!(c, control_x(1,2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               \n\n\njulia> simulate_shots(c, 99)\n99-element Vector{String}:\n \"11\"\n \"00\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"11\"\n \"00\"\n \"00\"\n \"11\"\n ⋮\n \"00\"\n \"00\"\n \"11\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n \"00\"\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.get_measurement_probabilities-Tuple{QuantumCircuit}","page":"Library","title":"Qanuk.get_measurement_probabilities","text":"get_measurement_probabilities(circuit::QuantumCircuit,\n    [target_qubits::Vector{<:Integer}])::AbstractVector{<:Real}\n\nReturns a vector listing the measurement probabilities for the target_qubits in the circuit.\n\nIf no target_qubits are provided, the probabilities are computed for all the qubits.\n\nThe measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit QuantumCircuit, the probabilities are listed for 00, 01, 10, and 11.\n\nExamples\n\nThe following example constructs a QuantumCircuit where the probability of measuring 01 is 50% and the probability of measuring 11 is also 50%.\n\njulia> circuit = QuantumCircuit(qubit_count=2);\n\njulia> push!(circuit, hadamard(1), sigma_x(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H───────\n               \nq[2]:───────X──\n               \n\n\n\njulia> get_measurement_probabilities(circuit)\n4-element Vector{Float64}:\n 0.0\n 0.4999999999999999\n 0.0\n 0.4999999999999999\n\n\nFor the same circuit, the probability of measuring qubit 2 and finding 1 is 100%.\n\njulia> target_qubit = [2];\n\njulia> get_measurement_probabilities(circuit, target_qubit)\n2-element Vector{Float64}:\n 0.0\n 0.9999999999999998\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Base.inv-Tuple{QuantumCircuit}","page":"Library","title":"Base.inv","text":"inv(circuit::QuantumCircuit)\n\nReturn a QuantumCircuit which is the inverse of the input circuit.  Each gate is replaced by it's corresponding inverse, and the order of gates is reversed.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=2);\n\njulia> push!(c, rotation_y(1, pi/4));\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Ry(0.7854)────*──\n                     |  \nq[2]:────────────────X──\n                        \n\n\n\njulia> inv(c)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──*────Ry(-0.7854)──\n       |                 \nq[2]:──X─────────────────\n                         \n\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Qanuk.get_num_gates_per_type","page":"Library","title":"Qanuk.get_num_gates_per_type","text":"get_num_gates_per_type(circuit::QuantumCircuit)::AbstractDict{<:AbstractString, <:Integer}\n\nReturns a dictionary listing the number of gates of each type found in the circuit.\n\nThe dictionary keys are the instruction_symbol of the gates while the values are the number of gates found.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=2);\n\njulia> push!(c, hadamard(1), hadamard(2));\n\njulia> push!(c, control_x(1, 2));\n\njulia> push!(c, hadamard(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*───────\n                 |       \nq[2]:───────H────X────H──\n                         \n\n\n\njulia> get_num_gates_per_type(c)\nDict{String, Int64} with 2 entries:\n  \"h\"  => 3\n  \"cx\" => 1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.get_num_gates","page":"Library","title":"Qanuk.get_num_gates","text":"get_num_gates(circuit::QuantumCircuit)::Integer\n\nReturns the number of gates in the circuit.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=2);\n\njulia> push!(c, hadamard(1), hadamard(2));\n\njulia> push!(c, control_x(1, 2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H─────────*──\n                 |  \nq[2]:───────H────X──\n                    \n\n\n\njulia> get_num_gates(c)\n3\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.serialize_job","page":"Library","title":"Qanuk.serialize_job","text":"serialize_job(circuit::QuantumCircuit,repetitions::Integer)\n\nCreates a JSON-formatted String containing the circuit configuration to be sent  to a QPU service, along with the number of repetitions requested.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count = 2,gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> serialize_job(c,10)\n\"{\\\"num_repetitions\\\":10,\\\"circuit\\\":{\\\"operations\\\":[{\\\"parameters\\\":{},\\\"type\\\":\\\"x\\\",\\\"qubits\\\":[0]}]}}\"\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.transpile","page":"Library","title":"Qanuk.transpile","text":"transpile(::CompressSingleQubitGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CompressSingleQubitGatesTranspiler transpiler stage  which gathers all single-qubit gates sharing a common target in an input  circuit and combines them into single Universal gates in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CompressSingleQubitGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X────Y──\n               \nq[2]:──────────\n               \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=3.1416,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────Y─────────P(1.0472)──\n                                 \nq[2]:────────────*───────────────\n                 |               \nq[3]:────────────X───────────────\n                                 \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──U(θ=0.0000,ϕ=-2.0944,λ=0.0000)───────\n                                            \nq[2]:────────────────────────────────────*──\n                                         |  \nq[3]:────────────────────────────────────X──\n                                            \n\n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CastSwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastSwapToCZGateTranspiler transpiler stage which expands all Swap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastSwapToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[swap(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──☒──\n       |\nq[2]:──☒──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:───────────*────Y_m90────────────*────Y_90─────────────*──────────\n                |                     |                     |          \nq[2]:──Y_m90────Z─────────────Y_90────Z────────────Y_m90────Z────Y_90──\n                                              \n\n\n\n\n\n\ntranspile(::CastCXToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastCXToCZGateTranspiler transpiler stage which expands all CX gates into CZ and Hadamard gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastCXToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[control_x(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──*──\n       |\nq[2]:──X──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:───────*───────\n            |\nq[2]:──H────Z────H──\n\n\n\n\n\ntranspile(::CastISwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastISwapToCZGateTranspiler transpiler stage which expands all ISwap gates into CZ gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastISwapToCZGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[iswap(1, 2)])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──x──\n       |\nq[2]:──x──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Y_m90─────────────*────Y_90─────────────*────Y_90──────────\n                         |                     |                  \nq[2]:───────────X_m90────Z────────────X_m90────Z────────────X_90──\n                                                                  \n\n\n\n\n\n\ntranspile(::CastToffoliToCXGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastToffoliToCXGateTranspiler transpiler stage which expands all Toffoli gates into CX gates and single-qubit gates. The result of the input and output circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastToffoliToCXGateTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[toffoli(1, 2, 3)])\nQuantum Circuit Object:\n   qubit_count: 3\nq[1]:──*──\n       |\nq[2]:──*──\n       |\nq[3]:──X──\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──────────────────*────────────────────*──────────────*─────────T──────────*──\n                       |                    |              |                    |  \nq[2]:───────*──────────|─────────*──────────|────T─────────X──────────────T†────X──\n            |          |         |          |                                      \nq[3]:──H────X────T†────X────T────X────T†────X─────────T─────────H──────────────────\n                                                                                   \n\n\n\n\n\n\ntranspile(::CastToPhaseShiftAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastToPhaseShiftAndHalfRotationXTranspiler transpiler stage  which converts all single-qubit gates in an input circuit and converts them  into combinations of PhaseShift and RotationX with angle π/2 in an output  circuit. For any gate in the input circuit, the number of gates in the  output varies between zero and 5. The result of the input and output  circuit on any arbitrary state Ket is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastToPhaseShiftAndHalfRotationXTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────X_90────Z────X_m90──\n                                                 \nq[2]:───────────────────────────\n                                                 \n\n\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Y──\n          \nq[2]:─────\n          \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z_90────X_90────Z────X_m90────Z_90──\n                                           \nq[2]:──────────────────────────────────────\n                                           \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0.,0.,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CastUniversalToRzRxRzTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastUniversalToRzRxRzTranspiler transpiler stage  which finds Universal gates in an input circuit and converst casts  them into a sequence of PhaseShift (Rz), RotationX (Rx) and  PhaseShift (Rz) gates in a new circuit. The result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastUniversalToRzRxRzTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,π/2,π/4,π/8)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=1.5708,ϕ=0.7854,λ=0.3927)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(-1.1781)────Rx(1.5708)────P(2.3562)──\n                                              \nq[2]:─────────────────────────────────────────\n                                              \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0,π/4,0)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.7854,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                      \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(-1.5708)────Rx(0.0000)────P(2.3562)──\n                                              \nq[2]:─────────────────────────────────────────\n                                              \n                                        \njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CastRxToRzAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CastRxToRzAndHalfRotationXTranspiler transpiler stage  which finds RotationX(θ) gates in an input circuit and converts (casts)  them into a sequence of gates: Z90,X90,PhaseShift(θ),XM90,ZM90 in a new circuit. The result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CastRxToRzAndHalfRotationXTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,π/8)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rx(0.3927)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z_90────X_90────P(0.3927)────X_m90────Z_m90──\n                                                    \nq[2]:───────────────────────────────────────────────\n                                                    \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::SimplifyRxGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SimplifyRxGatesTranspiler transpiler stage  which finds RotationX gates in an input circuit and according to it's  angle theta, casts them to one of the right-angle RotationX gates,  e.g. SigmaX, X90, or XM90. In the case where theta≈0., the gate is removed. The result of the input and output circuit on any arbitrary state Ket is  unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=SimplifyRxGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,pi/2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rx(1.5708)──\n                   \nq[2]:──────────────\n                   \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X_90──\n             \nq[2]:────────\n             \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,pi)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rx(3.1416)──\n                   \nq[2]:──────────────\n                   \n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X──\n          \nq[2]:─────\n          \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Rx(0.0000)──\n                   \nq[2]:──────────────\n                   \n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::SwapQubitsForLineConnectivityTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SwapQubitsForLineConnectivityTranspiler transpiler stage  which adds Swap gates around multi-qubit gates so that the  final Operator acts on adjacent qubits. The result of the input  and output circuit on any arbitrary state Ket is unchanged  (up to a global phase).\n\nExamples\n\njulia> transpiler=SwapQubitsForLineConnectivityTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 6, gates=[toffoli(4,6,1)])\nQuantum Circuit Object:\n   qubit_count: 6 \nq[1]:──X──\n       |  \nq[2]:──|──\n       |  \nq[3]:──|──\n       |  \nq[4]:──*──\n       |  \nq[5]:──|──\n       |  \nq[6]:──*──\n          \n\n\n\n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 6 \nq[1]:───────────────────────────X───────────────────────────\n                                |                           \nq[2]:───────☒───────────────────*───────────────────☒───────\n            |                   |                   |       \nq[3]:──☒────☒──────────────☒────*────☒──────────────☒────☒──\n       |                   |         |                   |  \nq[4]:──☒──────────────☒────☒─────────☒────☒──────────────☒──\n                      |                   |                 \nq[5]:────────────☒────☒───────────────────☒────☒────────────\n                 |                             |            \nq[6]:────────────☒─────────────────────────────☒────────────\n                                                            \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::SimplifyRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SimplifyRzGatesTranspiler transpiler stage  which finds PhaseShift gates in an input circuit and according to it's  phase angle phi, casts them to one of the right-angle RotationZ gates,  e.g. SigmaZ, Z90, ZM90, Pi8 or Pi8Dagger. In the case where phi≈0., the  gate is removed. The result of the input and output circuit on any  arbitrary state Ket is unchanged (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional  argument to the Transpiler, e.g: transpiler=SimplifyRzGatesTranspiler(1.0e-10)\n\nExamples\n\njulia> transpiler=SimplifyRzGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,pi/2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(1.5708)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z_90──\n             \nq[2]:────────\n             \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,pi)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(3.1416)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z──\n          \nq[2]:─────\n          \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(0.0000)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n     \n\n\n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::CompressRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the CompressRzGatesTranspiler transpiler stage  which gathers all Rz-type gates sharing a common target in an input  circuit and combines them into single PhaseShift gate in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state Ket  is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=CompressRzGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_z(1),z_90(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────Z_90──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(-1.5708)──\n                   \nq[2]:──────────────\n                   \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_z(1),pi_8(1),control_x(2,3),z_minus_90(1)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──Z────T─────────Z_m90──\n                             \nq[2]:────────────*───────────\n                 |           \nq[3]:────────────X───────────\n                             \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──P(2.3562)───────\n                       \nq[2]:───────────────*──\n                    |  \nq[3]:───────────────X──\n                       \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\ntranspile(::RemoveSwapBySwappingGates, circuit::QuantumCircuit)::QuantumCircuit\n\nRemoves the Swap gates from the circuit assuming all-to-all connectivity.\n\nwarning: The initial state must be the ground state!\nThis transpiler stage assumes that the input state is 0rangle^otimes N where N is the number of qubits. The stage should not be used on sub-circuits where the input state is not 0rangle^otimes N.\n\nThis transpiler stage eliminates Swap gates by moving the gates preceding each Swap gate.\n\nExamples\n\njulia> transpiler = RemoveSwapBySwappingGates();\n\njulia> circuit = QuantumCircuit(qubit_count=2, gates=[hadamard(1), swap(1,2), sigma_x(2)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────☒───────\n            |       \nq[2]:───────☒────X──\n                    \n\n\n\njulia> transpiled_circuit = transpile(transpiler, circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──────────\n               \nq[2]:──H────X──\n               \n\n\n\n\n\n\n\n\ntranspile(::SimplifyTrivialGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit\n\nImplementation of the SimplifyTrivialGatesTranspiler transpiler stage  which finds gates which have no effect on the state Ket, such as Identity, and  parameterized gates with null parameters such as rotation_x(target, 0.). The result of the input and output circuit on any  arbitrary state Ket is unchanged (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional  argument to the Transpiler, e.g: transpiler=SimplifyTrivialGatesTranspiler(1.0e-10)\n\nExamples\n\njulia> transpiler=SimplifyTrivialGatesTranspiler();\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[identity_gate(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──I──\n          \nq[2]:─────\n          \njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──P(0.0000)──\n                  \nq[2]:─────────────\n                  \n\njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0.,0.,0.)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──\n                                      \nq[2]:─────────────────────────────────\n                                             \njulia> transpiled_circuit=transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:      \n\njulia> compare_circuits(circuit,transpiled_circuit)\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.compare_circuits","page":"Library","title":"Qanuk.compare_circuits","text":"compare_circuits(c0::QuantumCircuit,c1::QuantumCircuit)::Bool\n\nTests for equivalence of two circuits based on their effect on an  arbitrary input state (a Ket). Circuits are equivalent if they both  yield the same output for any input, up to a global phase. Circuits with different ordering of gates that apply on different  targets can also be equivalent.\n\nExamples\n\njulia> c0 = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──X────Y──\n               \n\n\n\njulia> c1 = QuantumCircuit(qubit_count = 1, gates=[phase_shift(1,π)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──P(3.1416)──\n                  \n\n\n\njulia> compare_circuits(c0,c1)\ntrue            \n\njulia> c0 = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────Y───────\n                    \nq[2]:────────────*──\n                 |  \nq[3]:────────────X──\n                    \n\n\n\njulia> c1 = QuantumCircuit(qubit_count = 3, gates=[control_x(2,3),sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:───────X────Y──\n                    \nq[2]:──*────────────\n       |            \nq[3]:──X────────────\n                    \n\n\n\njulia> compare_circuits(c0,c1)\ntrue    \n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.circuit_contains_gate_type","page":"Library","title":"Qanuk.circuit_contains_gate_type","text":"circuit_contains_gate_type(circuit::QuantumCircuit, gate_type::Type{<:AbstractGate})::Bool\n\nDetermined whether or not a type of gate is present in a circuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──X────Y──\n               \njulia> circuit_contains_gate_type(circuit, Qanuk.SigmaX)\ntrue\n               \njulia> circuit_contains_gate_type(circuit, Qanuk.ControlZ)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.permute_qubits!","page":"Library","title":"Qanuk.permute_qubits!","text":"permute_qubits!(circuit::QuantumCircuit,\n    qubit_mapping::AbstractDict{T,T}) where T<:Integer\n\nModifies a circuit by moving the gates to other qubits based on a qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.\n\nFor instance, Dict(1=>2) is not a valid qubit_mapping, but Dict(1=>2, 2=>1) is valid.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=3);\n\njulia> push!(c, sigma_x(1), hadamard(2), sigma_y(3))\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────────────\n                    \nq[2]:───────H───────\n                    \nq[3]:────────────Y──                    \n\n\n\njulia> permute_qubits!(c, Dict(1=>3, 3=>1))\n\njulia> show(c)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:────────────Y──\n                    \nq[2]:───────H───────\n                    \nq[3]:──X────────────\n                    \n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.permute_qubits","page":"Library","title":"Qanuk.permute_qubits","text":"permute_qubits(circuit::QuantumCircuit,\n    qubit_mapping::AbstractDict{T,T})::QuantumCircuit where T<:Integer\n\nReturns a QuantumCircuit that is a copy of circuit but where the gates have been moved to other qubits based on a qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.\n\nFor instance, Dict(1=>2) is not a valid qubit_mapping, but Dict(1=>2, 2=>1) is valid.\n\nExamples\n\njulia> c = QuantumCircuit(qubit_count=3);\n\njulia> push!(c, sigma_x(1), hadamard(2), sigma_y(3))\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────────────\n                    \nq[2]:───────H───────\n                    \nq[3]:────────────Y──\n                    \n\n\n\njulia> permute_qubits(c, Dict(1=>3, 3=>1))\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:────────────Y──\n                    \nq[2]:───────H───────\n                    \nq[3]:──X────────────\n                    \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Quantum-Gates","page":"Library","title":"Quantum Gates","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"AbstractGate\neye\nidentity_gate\nsigma_p\nsigma_m\nsigma_x\nsigma_y\nsigma_z\nhadamard\npi_8\npi_8_dagger\nx_90\nx_minus_90\ny_90\ny_minus_90\nz_90\nz_minus_90\nrotation\nrotation_x\nrotation_y\nphase_shift\nuniversal\ncontrol_z\ncontrol_x\niswap\nswap\ntoffoli\niswap_dagger\nBase.:*(M::AbstractGate, x::Ket)\napply_gate!\nget_operator\ninv(gate::AbstractGate)\nis_gate_type\nget_gate_type\nmove_gate","category":"page"},{"location":"library.html#Qanuk.AbstractGate","page":"Library","title":"Qanuk.AbstractGate","text":"AbstractGate\n\nA Gate is an instantiation of an AbstractGate, which can be added to a QuantumCircuit in order to apply an operator to one or more target qubits. AbstractGate is useful to dispatch all Gates to default implementation of functions such as getconnectedqubits().  Those functions are then specialized for Gates requiring a different implementation. \n\nAbstractGate is an abstract type, which means that it cannot be instantiated.  Instead, each concrete type of Gate is a struct which is a subtype of AbstractGate. Each descendant of AbstractGate must have at least the following fields:\n\ntarget::Int: the qubit number to which the Gate is applied. Some gates have multiple targets.\nparameter::Real: for parameterized gates, determines which operation is applied (e.g. rotation angles), i.e., is used in the construction of the matrix used in the application of its Operator.\n\nExamples\n\nA struct must be defined for each new gate type, such as the following X_45 gate which applies a 45° rotation about the X axis:\n\njulia> struct X45 <: AbstractGate\n           target::Int\n       end;\n\n\nFor convenience, a constructor can be defined:\n\njulia> x_45(target::Integer) = X45(target);\n\n\nTo simulate the effect of the gate in a QuantumCircuit or when applied to a Ket, the function get_operator must be extended.\n\njulia> Qanuk.get_operator(gate::X45, T::Type{<:Complex}=ComplexF64) = rotation_x(π/4, T);\n\n\nThe gate inverse can also be specified by extending the inv function.\n\njulia> inv(gate::X45) = rotation_x(gate.target, -π/4);\n\n\nAn instance of the X_45 gate can now be created:\n\njulia> x_45_gate = x_45(1)\nGate Object: X45\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n0.9238795325112867 + 0.0im    0.0 - 0.3826834323650898im\n0.0 - 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\njulia> inv(x_45_gate)\nGate Object: Qanuk.RotationX\nParameters: \ntheta\t: -0.7853981633974483\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n0.9238795325112867 + 0.0im    -0.0 + 0.3826834323650898im\n-0.0 + 0.3826834323650898im    0.9238795325112867 + 0.0im\n\n\n\nTo enable printout of a circuit containing our new gate type, a symbol  must be defined as follows.\n\njulia> Qanuk.gates_display_symbols[X45]=[\"X45\"];\n\n\nIf this gate is to be sent as an instruction to a hardware QPU,  an instruction string must be defined.\n\njulia> Qanuk.gates_instruction_symbols[X45]=\"x45\";\n\n\nA circuit containing this gate can now be constructed:\n\njulia> circuit=QuantumCircuit(qubit_count=2,gates=[x_45_gate])\nQuantum Circuit Object:\n   qubit_count: 2\nq[1]:──X45──\n\nq[2]:───────\n\n\n\n\n\n","category":"type"},{"location":"library.html#Qanuk.eye","page":"Library","title":"Qanuk.eye","text":"eye(),\neye(size::Integer)\n\nReturn the identity matrix as a DenseOperator, which is defined as:\n\nI = beginbmatrix\n    1  0 \n    0  1\n    endbmatrix\n\nCalling eye(size) will produce an identity matrix DenseOperator  of dimensions (size,size).\n\nExamples\n\njulia> eye()\n(2, 2)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\njulia> eye(4)\n(4, 4)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.identity_gate","page":"Library","title":"Qanuk.identity_gate","text":"identity_gate(target)\n\nReturn the Identity Gate, which applies the identity_gate() IdentityOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.sigma_p","page":"Library","title":"Qanuk.sigma_p","text":"sigma_p()\n\nReturn the spin-frac12 raising Operator, which is defined as:\n\nsigma_+ = beginbmatrix\n    0  1 \n    0  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.sigma_m","page":"Library","title":"Qanuk.sigma_m","text":"sigma_m()\n\nReturn the spin-frac12 lowering Operator, which is defined as:\n\nsigma_- = beginbmatrix\n    0  0 \n    1  0\n    endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.sigma_x","page":"Library","title":"Qanuk.sigma_x","text":"sigma_x()\n\nReturn the Pauli-X AntiDiagonalOperator, which is defined as:\n\nsigma_x = beginbmatrix\n    0  1 \n    1  0\n    endbmatrix\n\n\n\n\n\nsigma_x(target)\n\nReturn the Pauli-X Gate, which applies the sigma_x() AntiDiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.sigma_y","page":"Library","title":"Qanuk.sigma_y","text":"sigma_y()\n\nReturn the Pauli-Y Operator, which is defined as:\n\nsigma_y = beginbmatrix\n    0  -i \n    i  0\n    endbmatrix\n\n\n\n\n\nsigma_y(target)\n\nReturn the Pauli-Y Gate, which applies the sigma_y() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.sigma_z","page":"Library","title":"Qanuk.sigma_z","text":"sigma_z()\n\nReturn the Pauli-Z Operator, which is defined as:\n\nsigma_z = beginbmatrix\n    1  0 \n    0  -1\n    endbmatrix\n\n\n\n\n\nsigma_z(target)\n\nReturn the Pauli-Z Gate, which applies the sigma_z() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.hadamard","page":"Library","title":"Qanuk.hadamard","text":"hadamard()\n\nReturn the Hadamard Operator, which is defined as:\n\nH = frac1sqrt2beginbmatrix\n    1  1 \n    1  -1\n    endbmatrix\n\n\n\n\n\nhadamard(target)\n\nReturn the Hadamard Gate, which applies the hadamard() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.pi_8","page":"Library","title":"Qanuk.pi_8","text":"pi_8()\n\nReturn the Operator for the π/8 gate, which is defined as:\n\nT = beginbmatrix\n    1  0 \n    0  e^ifracpi4\n    endbmatrix\n\n\n\n\n\npi_8(target)\n\nReturn a π/8 Gate (also known as a T Gate), which applies the pi_8() DiagonalOperator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.pi_8_dagger","page":"Library","title":"Qanuk.pi_8_dagger","text":"pi_8_dagger()\n\nReturn the adjoint DiagonalOperator of the π/8 gate, which is defined as:\n\nT^dagger = beginbmatrix\n    1  0 \n    0  e^-ifracpi4\n    endbmatrix\n\n\n\n\n\npi_8_dagger(target)\n\nReturn an adjoint π/8 Gate (also known as a T^dagger Gate), which applies the pi_8_dagger() Operator to the target qubit.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.x_90","page":"Library","title":"Qanuk.x_90","text":"x_90()\n\nReturn the Operator which applies a π/2 rotation about the X axis.\n\nThe Operator is defined as:\n\nR_xleft(fracpi2right) = frac1sqrt2beginbmatrix\n    1  -i \n    -i  1\n    endbmatrix\n\n\n\n\n\nx_90(target)\n\nReturn a Gate that applies a 90° rotation about the X axis as defined by the x_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.x_minus_90","page":"Library","title":"Qanuk.x_minus_90","text":"x_minus_90()\n\nReturn the Operator which applies a -π/2 rotation about the X axis.\n\nThe Operator is defined as:\n\nR_xleft(-fracpi2right) = frac1sqrt2beginbmatrix\n    1  i \n    i  1\n    endbmatrix\n\n\n\n\n\nx_minus_90(target)\n\nReturn a Gate that applies a -90° rotation about the X axis as defined by the x_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.y_90","page":"Library","title":"Qanuk.y_90","text":"y_90()\n\nReturn the Operator which applies a π/2 rotation about the Y axis.\n\nThe Operator is defined as:\n\nR_yleft(fracpi2right) = frac1sqrt2beginbmatrix\n    1  -1 \n    1  1\n    endbmatrix\n\n\n\n\n\ny_90(target)\n\nReturn a Gate that applies a 90° rotation about the Y axis as defined by the y_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.y_minus_90","page":"Library","title":"Qanuk.y_minus_90","text":"y_minus_90()\n\nReturn the Operator which applies a -π/2 rotation about the Y axis.\n\nThe Operator is defined as:\n\nR_yleft(-fracpi2right) = frac1sqrt2beginbmatrix\n    1  1 \n    -1  1\n    endbmatrix\n\n\n\n\n\ny_minus_90(target)\n\nReturn a Gate that applies a -90° rotation about the Y axis as defined by the y_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.z_90","page":"Library","title":"Qanuk.z_90","text":"z_90()\n\nReturn the Operator which applies a π/2 rotation about the Z axis.\n\nThe Operator is defined as:\n\nR_zleft(fracpi2right) = beginbmatrix\n    1  0 \n    0  i\n    endbmatrix\n\n\n\n\n\nz_90(target)\n\nReturn a Gate that applies a 90° rotation about the Z axis as defined by the z_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.z_minus_90","page":"Library","title":"Qanuk.z_minus_90","text":"z_minus_90()\n\nReturn the Operator which applies a -π/2 rotation about the Z axis.\n\nThe Operator is defined as:\n\nR_zleft(-fracpi2right) = beginbmatrix\n    1  0 \n    0  -i\n    endbmatrix\n\n\n\n\n\nz_minus_90(target)\n\nReturn a Gate that applies a -90° rotation about the Z axis as defined by the z_minus_90() Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.rotation","page":"Library","title":"Qanuk.rotation","text":"rotation(theta, phi)\n\nReturn the Operator which applies a rotation theta about the cos(phi)X+sin(phi)Y axis.\n\nThe Operator is defined as:\n\nR(theta phi) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -i e^-iphi mathrmsinleft(fractheta2right) 05em      \n    -i e^iphi mathrmsinleft(fractheta2right) \n        mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation(target, theta, phi)\n\nReturn a gate that applies a rotation theta to the target qubit about the cos(phi)X+sin(phi)Y axis.\n\nThe corresponding Operator is rotation(theta, phi).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.rotation_x","page":"Library","title":"Qanuk.rotation_x","text":"rotation_x(theta)\n\nReturn the Operator which applies a rotation theta about the X axis.\n\nThe Operator is defined as:\n\nR_x(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -imathrmsinleft(fractheta2right) 05em      \n-imathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_x(target, theta)\n\nReturn a Gate that applies a rotation theta about the X axis of the target qubit.\n\nThe corresponding Operator is rotation_x(theta).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.rotation_y","page":"Library","title":"Qanuk.rotation_y","text":"rotation_y(theta)\n\nReturn the Operator that applies a rotation theta about the Y axis of the target qubit.\n\nThe Operator is defined as:\n\nR_y(theta) = beginbmatrix\nmathrmcosleft(fractheta2right) \n    -mathrmsinleft(fractheta2right) 05em      \nmathrmsinleft(fractheta2right) \n    mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nrotation_y(target, theta)\n\nReturn a Gate that applies a rotation theta about the Y axis of the target qubit.\n\nThe corresponding Operator is rotation_y(theta).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.phase_shift","page":"Library","title":"Qanuk.phase_shift","text":"phase_shift(phi)\n\nReturn the DiagonalOperator that applies a phase shift phi.\n\nThe DiagonalOperator is defined as:\n\nP(phi) = beginbmatrix\n    1  0 05em      \n    0  e^iphi\nendbmatrix\n\n\n\n\n\nphase_shift(target, phi)\n\nReturn a Gate that applies a phase shift phi to the target qubit as defined by the phase_shift(phi) DiagonalOperator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.universal","page":"Library","title":"Qanuk.universal","text":"universal(theta, phi, lambda)\n\nReturn the Operator which performs a rotation about the angles theta, phi, and lambda. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU\n\nThe Operator is defined as:\n\nU(theta phi lambda) = beginbmatrix\n    mathrmcosleft(fractheta2right) \n        -e^ilambdamathrmsinleft(fractheta2right) 05em      \n    e^iphimathrmsinleft(fractheta2right) \n        e^ileft(phi+lambdaright)mathrmcosleft(fractheta2right)\nendbmatrix\n\n\n\n\n\nuniversal(target, theta, phi, lambda)\n\nReturn a gate which rotates the target qubit given the angles theta, phi, and lambda. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU\n\nThe corresponding Operator is universal(theta, phi, lambda).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.control_z","page":"Library","title":"Qanuk.control_z","text":"control_z()\n\nReturn the controlled-Z Operator, which is defined as:\n\nCZ = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  1  0 \n    0  0  0  -1\n    endbmatrix\n\n\n\n\n\ncontrol_z(control_qubit, target_qubit)\n\nReturn a controlled-Z gate given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_z().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.control_x","page":"Library","title":"Qanuk.control_x","text":"control_x()\n\nReturn the controlled-X (or controlled NOT) Operator, which is defined as:\n\nCX = CNOT = beginbmatrix\n    1  0  0  0 \n    0  1  0  0 \n    0  0  0  1 \n    0  0  1  0\n    endbmatrix\n\n\n\n\n\ncontrol_x(control_qubit, target_qubit)\n\nReturn a controlled-X gate (also known as a controlled NOT gate) given a control_qubit and a target_qubit.\n\nThe corresponding Operator is control_x().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.iswap","page":"Library","title":"Qanuk.iswap","text":"iswap()\n\nReturn the imaginary swap Operator, which is defined as:\n\niSWAP = beginbmatrix\n    1  0  0  0 \n    0  0  i  0 \n    0  i  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\niswap(qubit_1, qubit_2)\n\nReturn the imaginary swap Gate which applies the imaginary swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is iswap().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.swap","page":"Library","title":"Qanuk.swap","text":"swap()\n\nReturn the swap Operator, which is defined as:\n\niSWAP = beginbmatrix\n    1  0  0  0 \n    0  0  1  0 \n    0  1  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\nswap(qubit_1, qubit_2)\n\nReturn the swap Gate which applies the swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is swap().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.toffoli","page":"Library","title":"Qanuk.toffoli","text":"toffoli()\n\nReturn the Toffoli Operator, which is defined as:\n\nCCX = CCNOT = beginbmatrix\n    1  0  0  0  0  0  0  0 \n    0  1  0  0  0  0  0  0 \n    0  0  1  0  0  0  0  0 \n    0  0  0  1  0  0  0  0 \n    0  0  0  0  1  0  0  0 \n    0  0  0  0  0  1  0  0 \n    0  0  0  0  0  0  0  1 \n    0  0  0  0  0  0  1  0\n    endbmatrix\n\n\n\n\n\ntoffoli(control_qubit_1, control_qubit_2, target_qubit)\n\nReturn a Toffoli gate (also known as a CCNOT gate) given two control qubits and a target_qubit.\n\nThe corresponding Operator is toffoli().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.iswap_dagger","page":"Library","title":"Qanuk.iswap_dagger","text":"iswap_dagger()\n\nReturn the adjoint of the imaginary swap Operator, which is defined as:\n\niSWAP^dagger = beginbmatrix\n    1  0  0  0 \n    0  0  -i  0 \n    0  -i  0  0 \n    0  0  0  1\n    endbmatrix\n\n\n\n\n\niswap_dagger(qubit_1, qubit_2)\n\nReturn the adjoint imaginary swap Gate which applies the adjoint imaginary swap Operator to qubit_1 and qubit_2.\n\nThe corresponding Operator is iswap_dagger().\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.:*-Tuple{AbstractGate, Ket}","page":"Library","title":"Base.:*","text":"Base.:*(M::AbstractGate, x::Ket)\n\nReturn a Ket which results from applying Gate M to Ket x.\n\nExamples\n\njulia> ψ_0 = fock(0, 2)\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ_1 = sigma_x(1)*ψ_0\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Qanuk.apply_gate!","page":"Library","title":"Qanuk.apply_gate!","text":"apply_gate!(state::Ket, gate::Gate)\n\nUpdate the state by applying a gate to it.\n\nExamples\n\njulia> ψ_0 = fock(0, 2)\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> apply_gate!(ψ_0, sigma_x(1))\n\njulia> print(ψ_0)\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.get_operator","page":"Library","title":"Qanuk.get_operator","text":"get_operator(gate::Gate)\n\nReturns the Operator which is associated to a Gate.\n\nExamples\n\njulia> x = sigma_x(1);\n\njulia> get_operator(x)\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.inv-Tuple{AbstractGate}","page":"Library","title":"Base.inv","text":"inv(gate::AbstractGate)\n\nReturn a Gate which is the inverse of the input gate.\n\nExamples\n\njulia> u = universal(1, -pi/2, pi/3, pi/4)\nGate Object: Qanuk.Universal\nParameters: \ntheta\t: -1.5707963267948966\nphi\t: 1.0471975511965976\nlambda\t: 0.7853981633974483\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    0.5 + 0.4999999999999999im\n-0.3535533905932738 - 0.6123724356957945im    -0.18301270189221924 + 0.6830127018922194im\n\n\njulia> inv(u)\nGate Object: Qanuk.Universal\nParameters: \ntheta\t: 1.5707963267948966\nphi\t: -0.7853981633974483\nlambda\t: -1.0471975511965976\n\nConnected_qubits\t: [1]\nOperator:\n(2, 2)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    -0.3535533905932738 + 0.6123724356957945im\n0.5 - 0.4999999999999999im    -0.18301270189221924 - 0.6830127018922194im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Qanuk.is_gate_type","page":"Library","title":"Qanuk.is_gate_type","text":"is_gate_type(gate::AbstractGate, type::Type)::Bool\n\nDetermines if a gate is of the specified type.\n\nwarning: Use is_gate_type instead of isa!\nFor AbstractGate objects, is_gate_type should be used instead of isa. The utilization of isa could lead to unexpected behavior (e.g. if a gate has been moved).\n\nExamples\n\njulia> gate = sigma_x(1)\nGate Object: Qanuk.SigmaX\nConnected_qubits\t: [1]\nOperator:\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> is_gate_type(gate, Qanuk.SigmaX)\ntrue\n\njulia> is_gate_type(gate, Qanuk.SigmaY)\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.get_gate_type","page":"Library","title":"Qanuk.get_gate_type","text":"get_gate_type(gate::AbstractGate)::Type\n\nReturns the type of a gate.\n\nwarning: Use get_gate_type instead of typeof!\nFor AbstractGate objects, get_gate_type should be used instead of typeof. The utilization of typeof could lead to unexpected behavior (e.g. if a gate has been moved).\n\nExamples\n\njulia> gate = sigma_x(1)\nGate Object: Qanuk.SigmaX\nConnected_qubits\t: [1]\nOperator:\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> get_gate_type(gate)\nQanuk.SigmaX\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.move_gate","page":"Library","title":"Qanuk.move_gate","text":"move_gate(gate::AbstractGate,\n    qubit_mapping::AbstractDict{<:Integer,<:Integer})::AbstractGate\n\nReturns a copy of gate where the qubits on which the gate acts have been updated based on qubit_mapping.\n\nThe dictionary qubit_mapping contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit.\n\nExamples\n\njulia> gate = sigma_x(1)\nGate Object: Qanuk.SigmaX\nConnected_qubits\t: [1]\nOperator:\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> move_gate(gate, Dict(1=>2))\nGate Object: Qanuk.SigmaX\nConnected_qubits\t: [2]\nOperator:\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Quantum-Processing-Unit","page":"Library","title":"Quantum Processing Unit","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"AnyonQPU\nVirtualQPU\nClient\nget_host\nsubmit_circuit\nget_status\nget_result\nrun_job\ntranspile_and_run_job\nget_transpiler\nSequentialTranspiler","category":"page"},{"location":"library.html#Qanuk.AnyonQPU","page":"Library","title":"Qanuk.AnyonQPU","text":"AnyonQPU\n\nA data structure to represent a Anyon System's QPU.  \n\nFields\n\nclient                  ::Client – Client to the QPU server.\nstatus_request_throttle ::Function – Used to rate-limit job status requests.\n\nExample\n\njulia>  qpu = AnyonQPU(host=\"example.anyonsys.com\",user=\"test_user\",access_token=\"not_a_real_access_token\")\nQuantum Processing Unit:\n   manufacturer:  Anyon Systems Inc.\n   generation:    Yukon\n   serial_number: ANYK202201\n   qubit_count:   6 \n   connectivity_type:  linear\n\n\n\n\n\n","category":"type"},{"location":"library.html#Qanuk.VirtualQPU","page":"Library","title":"Qanuk.VirtualQPU","text":"VirtualQPU\n\nA data structure to represent a Quantum Simulator.  \n\nExample\n\njulia> qpu=VirtualQPU()\nQuantum Simulator:\n   developers:  Anyon Systems Inc.\n   package:     Qanuk.jl\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Qanuk.Client","page":"Library","title":"Qanuk.Client","text":"Client\n\nA data structure to represent a Client to a QPU service.  \n\nFields\n\nhost::String – URL of the QPU server.\nuser::String – Username.\naccess_token::String – User access token.\n\nExample\n\njulia> c = Client(host=\"http://example.anyonsys.com\",user=\"test_user\",access_token=\"not_a_real_access_token\")\nClient for QPU service:\n   host:         http://example.anyonsys.com\n   user:         test_user \n \n  \n\n\n\n\n\n","category":"type"},{"location":"library.html#Qanuk.get_host","page":"Library","title":"Qanuk.get_host","text":"get_host(Client)\n\nReturns host URL of a Client to a QPU service.  \n\nExample\n\njulia> c = Client(host=\"http://example.anyonsys.com\",user=\"test_user\",access_token=\"not_a_real_access_token\");\n\njulia> get_host(c)\n\"http://example.anyonsys.com\"\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.submit_circuit","page":"Library","title":"Qanuk.submit_circuit","text":"submit_circuit(client::Client,circuit::QuantumCircuit,num_repetitions::Integer)\n\nSubmit a circuit to a Client of QPU service, requesting a number of  repetitions (num_repetitions). Returns circuitID.  \n\nExample\n\njulia> submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.get_status","page":"Library","title":"Qanuk.get_status","text":"get_status(client::Client,circuitID::String)::Dict{String, String}\n\nObtain the status of a circuit computation through a Client of a QPU service. Returns status::Dict containing status[\"type\"]:      -\"queued\"   : Computation in queue.     -\"running\"  : Computation being processed.     -\"failed\"   : QPU service has returned an error message.     -\"succeeded\": Computation is completed, result is available.\n\nIn the case of status[\"type\"]==\"failed\", the server error is contained in status[\"message\"].\n\nExample\n\njulia> circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\njulia> get_status(client,circuitID)\nStatus: succeeded\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.get_result","page":"Library","title":"Qanuk.get_result","text":"get_result(client::Client,circuit::String)::Dict{String, Int}\n\nGet the histogram of a completed circuit calculation, through a Client of a QPU service,  by circuit identifier circuitID.\n\nExample\n\njulia> circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)\n\"8050e1ed-5e4c-4089-ab53-cccda1658cd0\"\n\njulia> get_status(client,circuitID);\n\njulia> get_result(client,circuitID)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.run_job","page":"Library","title":"Qanuk.run_job","text":"run_job(qpu::VirtualQPU, circuit::QuantumCircuit,num_repetitions::Integer)\n\nRun a circuit computation on a QPU simulator, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations.\n\nExample\n\njulia> qpu=VirtualQPU();\n\njulia> run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\nrun_job(qpu::AnyonQPU, circuit::QuantumCircuit, num_repetitions::Integer)\n\nRun a circuit computation on a QPU service, repeatedly for the specified number of repetitions (num_repetitions).\n\nReturns the histogram of the completed circuit calculations, or an error message.\n\nExample\n\njulia> qpu=AnyonQPU(client);\n\njulia> run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.transpile_and_run_job","page":"Library","title":"Qanuk.transpile_and_run_job","text":"transpile_and_run_job(qpu::VirtualQPU, circuit::QuantumCircuit,num_repetitions::Integer;transpiler::Transpiler=get_transpiler(qpu))\n\nThis method first transpiles the input circuit using either the default transpiler,  or any other transpiler passed as a key-word argument.   The transpiled circuit is then run on a QPU simulator, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations, or an error message.\n\nExample\n\njulia> qpu=VirtualQPU();\n\njulia> transpile_and_run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\ntranspile_and_run_job(qpu::AnyonQPU, circuit::QuantumCircuit,num_repetitions::Integer;transpiler::Transpiler=get_transpiler(qpu))\n\nThis method first transpiles the input circuit using either the default transpiler, or any other transpiler passed as a key-word argument. The transpiled circuit is then run on the AnyonQPU, repeatedly for the specified number of repetitions (num_repetitions).\n\nReturns the histogram of the completed circuit calculations, or an error message.\n\nExample\n\njulia> qpu=AnyonQPU(client_anyon);\n\njulia> transpile_and_run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)\nDict{String, Int64} with 1 entry:\n  \"001\" => 100\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.get_transpiler","page":"Library","title":"Qanuk.get_transpiler","text":"get_transpiler(qpu::AnyonQPU)::Transpiler\n\nReturns the transpiler associated with this QPU.\n\nExample\n\njulia> qpu=AnyonQPU(client);\n\njulia> get_transpiler(qpu)\nSequentialTranspiler(Transpiler[CastToffoliToCXGateTranspiler(), CastCXToCZGateTranspiler(), CastISwapToCZGateTranspiler(), SwapQubitsForLineConnectivityTranspiler(), CastSwapToCZGateTranspiler(), CompressSingleQubitGatesTranspiler(), SimplifyTrivialGatesTranspiler(1.0e-6), CastUniversalToRzRxRzTranspiler(), SimplifyRxGatesTranspiler(1.0e-6), CastRxToRzAndHalfRotationXTranspiler(), CompressRzGatesTranspiler(), SimplifyRzGatesTranspiler(1.0e-6)])\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.SequentialTranspiler","page":"Library","title":"Qanuk.SequentialTranspiler","text":"SequentialTranspiler(Vector{<:Transpiler})\n\nComposite transpiler object which is constructed from an array  of Transpilerstages. Callingtranspile(::SequentialTranspiler,::QuantumCircuit)will apply each stage in sequence to the input circuit, and return a transpiled output circuit. The result of the input and output  circuit on any arbitrary stateKet` is unchanged (up to a global phase).\n\nExamples\n\njulia> transpiler=SequentialTranspiler([CompressSingleQubitGatesTranspiler(),CastToPhaseShiftAndHalfRotationXTranspiler()]);\n\njulia> circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),hadamard(1)])\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X────H──\n               \nq[2]:──────────\n               \n\n\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──Z────X_90────Z_90────X_m90────Z──\n                                                              \nq[2]:───────────────────────────────────\n                                                              \n\n\n\njulia> circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──X────Y─────────P(1.0472)──  \n\nq[2]:────────────*───────────────\n                 |               \nq[3]:────────────X───────────────\n                                 \n\n\n\njulia> transpile(transpiler,circuit)\nQuantum Circuit Object:\n   qubit_count: 3 \nq[1]:──P(-2.0944)───────\n                        \nq[2]:────────────────*──\n                     |  \nq[3]:────────────────X──\n                        \n\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Quantum-Toolkit","page":"Library","title":"Quantum Toolkit","text":"","category":"section"},{"location":"library.html#Basic-Quantum-Objects","page":"Library","title":"Basic Quantum Objects","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"There are three basic quantum objects in Qanuk to simulate a quantum system. These objects are Ket, Bra, and AbstractOperator.","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"Ket\nBra\nDiagonalOperator\nAntiDiagonalOperator\nDenseOperator\nBase.adjoint\nis_hermitian\nBase.exp(A::AbstractOperator)\nBase.getindex(A::AbstractOperator, m::Int64, n::Int64)\nexpected_value(A::AbstractOperator, psi::Ket)\nsparse\neigen\ntr\nkron\nMultiBodySystem\ncommute\nanticommute\nnormalize!\nget_measurement_probabilities(x::Ket{Complex{T}}) where T<:Real\nket2dm\nfock_dm\nwigner\nmoyal\ngenlaguerre\nget_embed_operator\nget_num_qubits(x::AbstractOperator)\nget_num_qubits(x::Union{Ket, Bra})\nget_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)\nget_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)\nfock\nspin_up\nspin_down\ncreate\ndestroy\nnumber_op\ncoherent\nShrodingerProblem{T<:AbstractOperator, S<:Complex}\nLindbladProblem{T<:DenseOperator}\nsesolve\nlindblad_solve\ncompare_kets","category":"page"},{"location":"library.html#Qanuk.Ket","page":"Library","title":"Qanuk.Ket","text":"A Ket represents a quantum wavefunction and is mathematically equivalent to a column vector of complex values. The norm of a Ket should always be unity.  \n\nExamples\n\nAlthough NOT the preferred way, one can directly build a Ket object by passing a column vector as the initializer. \n\njulia> using Qanuk\n\njulia> ψ = Ket([1.0; 0.0; 0.0])\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\n\nA better way to initialize a Ket is to use a pre-built basis such as the fock basis. See fock for further information on this function. \n\njulia> ψ = fock(2, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Qanuk.Bra","page":"Library","title":"Qanuk.Bra","text":"A structure representing a Bra (i.e. a row vector of complex values). A Bra is created as the complex conjugate of a Ket.\n\nExamples\n\njulia> ψ = fock(1, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> _ψ = Bra(ψ)\n3-element Bra{ComplexF64}:\n0.0 - 0.0im\n1.0 - 0.0im\n0.0 - 0.0im\n\n\njulia> _ψ * ψ    # A Bra times a Ket is a scalar\n1.0 + 0.0im\n\njulia> ψ*_ψ     # A Ket times a Bra is an operator\n(3, 3)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Qanuk.DiagonalOperator","page":"Library","title":"Qanuk.DiagonalOperator","text":"A structure representing a diagonal quantum Operator (i.e. a complex matrix, with non-zero elements all lying on the diagonal).\n\nExamples\n\njulia> z = DiagonalOperator([1.0,-1.0])\n(2,2)-element Qanuk.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    -1.0 + 0.0im\n\njulia> z = DiagonalOperator([1.0+im,1.0,1.0,0.0-im])\n(4,4)-element Qanuk.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 1.0im    .    .    .\n.    1.0 + 0.0im    .    .\n.    .    1.0 + 0.0im    .\n.    .    .    0.0 - 1.0im\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Qanuk.AntiDiagonalOperator","page":"Library","title":"Qanuk.AntiDiagonalOperator","text":"A structure representing a anti-diagonal quantum Operator (i.e. a complex matrix, with non-zero elements all lying on the cross-diagonal).\n\nExamples\n\njulia> AntiDiagonalOperator([1,2])\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    2.0 + 0.0im    .\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Qanuk.DenseOperator","page":"Library","title":"Qanuk.DenseOperator","text":"A structure representing a quantum operator with a full (dense) matrix representation.\n\nExamples\n\njulia> z = DenseOperator([1.0 0.0;0.0 -1.0])\n(2, 2)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    -1.0 + 0.0im\n\n\nAlternatively:\n\njulia> z = rotation(π/2,-π/4)  \n(2, 2)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865476 + 0.0im    0.4999999999999999 - 0.5im\n-0.4999999999999999 - 0.5im    0.7071067811865476 + 0.0im\n\n\n\n\n\n\n\n","category":"type"},{"location":"library.html#Base.adjoint","page":"Library","title":"Base.adjoint","text":"Base.adjoint(x)\n\nCompute the adjoint (a.k.a. conjugate transpose) of a Ket, a Bra, or an Operator.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.is_hermitian","page":"Library","title":"Qanuk.is_hermitian","text":"is_hermitian(A::AbstractOperator)\n\nDetermine if Operator A is Hermitian (i.e. self-adjoint).\n\nExamples\n\njulia> Y = sigma_y()\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> is_hermitian(Y)\ntrue\n\njulia> P = sigma_p()\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    0.0 + 0.0im    .\n\n\njulia> is_hermitian(P)\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.exp-Tuple{AbstractOperator}","page":"Library","title":"Base.exp","text":"exp(A::AbstractOperator)\n\nCompute the matrix exponential of Operator A.\n\nExamples\n\njulia> X = sigma_x()\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> x_rotation_90_deg = exp(-im*π/4*X)\n(2, 2)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n0.7071067811865475 + 0.0im    0.0 - 0.7071067811865475im\n0.0 - 0.7071067811865475im    0.7071067811865475 + 0.0im\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Base.getindex-Tuple{AbstractOperator, Int64, Int64}","page":"Library","title":"Base.getindex","text":"getindex(A::AbstractOperator, i::Integer, j::Integer)\n\nAccess the element at row i and column j in the matrix corresponding to Operator A.\n\nExamples\n\njulia> Y = sigma_y()\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> Y[1,1]\n0.0 + 0.0im\n\njulia> Y[1,2]\n0.0 - 1.0im\n\njulia> Y[2,1]\n0.0 + 1.0im\n\njulia> Y[2,2]\n0.0 + 0.0im\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Qanuk.expected_value-Tuple{AbstractOperator, Ket}","page":"Library","title":"Qanuk.expected_value","text":"expected_value(A::AbstractOperator, psi::Ket)\n\nCompute the expectation value ⟨ψ|A|ψ⟩ given Operator A and Ket |ψ⟩.\n\nExamples\n\njulia> ψ = Ket([0.0; 1.0])\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> A = sigma_z()\n(2,2)-element Qanuk.DiagonalOperator:\nUnderlying data type: ComplexF64:\n1.0 + 0.0im    .\n.    -1.0 + 0.0im\n\n\njulia> expected_value(A, ψ)\n-1.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"library.html#SparseArrays.sparse","page":"Library","title":"SparseArrays.sparse","text":"sparse(x::AbstractOperator)\n\nReturns a SparseOperator representation of x.\n\nExamples\n\n```jldoctest julia> z = sparse(sigma_z()) (2, 2)-element Qanuk.SparseOperator: Underlying data ComplexF64:  1.0 + 0.0im        ⋅            ⋅       -1.0 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#LinearAlgebra.eigen","page":"Library","title":"LinearAlgebra.eigen","text":"eigen(A::AbstractOperator)\n\nCompute the eigenvalue decomposition of Operator A and return an Eigen factorization object F. Eigenvalues are found in F.values while eigenvectors are found in the matrix F.vectors. Each column of this matrix corresponds to an eigenvector. The ith eigenvector is extracted by calling F.vectors[:, i].\n\nExamples\n\njulia> X = sigma_x()\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\njulia> F = eigen(X);\n\njulia> eigenvalues = F.values\n2-element Vector{Float64}:\n -1.0\n  1.0\n\njulia> eigenvector_1 = F.vectors[:, 1]\n2-element Vector{ComplexF64}:\n -0.7071067811865475 + 0.0im\n  0.7071067811865475 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#LinearAlgebra.tr","page":"Library","title":"LinearAlgebra.tr","text":"tr(A::AbstractOperator)\n\nCompute the trace of Operator A.\n\nExamples\n\njulia> I = eye()\n(2, 2)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im\n\n\njulia> trace = tr(I)\n2.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.kron","page":"Library","title":"Base.kron","text":"kron(x, y)\n\nCompute the Kronecker product of two Kets or two  DenseOperator , DiagonalOperator, AntiDiagonalOperator. More details about the Kronecker product can be found here. \n\nExamples\n\njulia> ψ_0 = Ket([0.0; 1.0])\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\njulia> ψ_1 = Ket([1.0; 0.0])\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ_0_1 = kron(ψ_0, ψ_1)\n4-element Ket{ComplexF64}:\n0.0 + 0.0im\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> kron(sigma_x(), sigma_y())\n(4, 4)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 - 1.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 - 1.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.MultiBodySystem","page":"Library","title":"Qanuk.MultiBodySystem","text":"A structure representing a quantum multi-body system.\n\nFields\n\nhilbert_space_structure – a vector of integers specifying the local Hilbert space size for each \"body\" within the multi-body system. \n\n\n\n\n\n","category":"type"},{"location":"library.html#Qanuk.commute","page":"Library","title":"Qanuk.commute","text":"commute(A::AbstractOperator, B::AbstractOperator)\n\nReturns the commutation of A and B.\n\njulia> σ_x = sigma_x()\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> σ_y = sigma_y()\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    0.0 - 1.0im\n    0.0 + 1.0im    .\n\n\njulia> commute(σ_x,σ_y)\n(2,2)-element Qanuk.DiagonalOperator:\nUnderlying data type: ComplexF64:\n0.0 + 2.0im    .\n.    0.0 - 2.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.anticommute","page":"Library","title":"Qanuk.anticommute","text":"anticommute(A::AbstractOperator, B::AbstractOperator)\n\nReturns the anticommutation of A and B.\n\njulia> σ_x = sigma_x()\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\n\njulia> anticommute(σ_x,σ_x)\n(2,2)-element Qanuk.DiagonalOperator:\nUnderlying data type: ComplexF64:\n2.0 + 0.0im    .\n.    2.0 + 0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#LinearAlgebra.normalize!","page":"Library","title":"LinearAlgebra.normalize!","text":"normalize!(x::Ket)\n\nNormalizes Ket x such that its magnitude becomes unity.\n\njulia> ψ=Ket([1.,2.,4.])\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n2.0 + 0.0im\n4.0 + 0.0im\n\njulia> normalize!(ψ)\n3-element Ket{ComplexF64}:\n0.2182178902359924 + 0.0im\n0.4364357804719848 + 0.0im\n0.8728715609439696 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T<:Real","page":"Library","title":"Qanuk.get_measurement_probabilities","text":"get_measurement_probabilities(x::Ket{Complex{T}},\n    [target_bodies::Vector{U},\n    hspace_size_per_body::Union{U,Vector{U}}=2])::AbstractVector{T}\n    where {T<:Real, U<:Integer}\n\nReturns a vector listing the measurement probabilities of the target_bodies of Ket x.\n\nThe Hilbert space size per body can be specified by providing a Vector of Integer for the hspace_size_per_body argument. The Vector must specify the Hilbert space size for each body. If the space size is uniform, a single Integer can be given instead. If only x is provided, the probabilities are provided for all the bodies.\n\nThe measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit Ket, the probabilities are listed for 00, 01, 10, and 11.\n\nExamples\n\nThe following example constructs a Ket, where the probability of measuring 00 is 50% and the probability of measuring 10 is also 50%.\n\njulia> ψ = 1/sqrt(2)*Ket([1, 0, 1, 0])\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_measurement_probabilities(ψ)\n4-element Vector{Float64}:\n 0.4999999999999999\n 0.0\n 0.4999999999999999\n 0.0\n\n\nFor the same Ket, the probability of measuring qubit 2 and finding 0 is 100%.\n\njulia> target_qubit = [2];\n\njulia> get_measurement_probabilities(ψ, target_qubit)\n2-element Vector{Float64}:\n 0.9999999999999998\n 0.0\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Qanuk.ket2dm","page":"Library","title":"Qanuk.ket2dm","text":"ket2dm(ψ::Ket)\n\nReturns the density matrix corresponding to the pure state ψ.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.fock_dm","page":"Library","title":"Qanuk.fock_dm","text":"fock_dm(i::Int64, hspace_size::Int64)\n\nReturns the density matrix corresponding to the Fock base i defined in a Hilbert space of size hspace_size.\n\njulia> dm=fock_dm(0,2)\n(2, 2)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.wigner","page":"Library","title":"Qanuk.wigner","text":"wigner(ρ::AbstractOperator, p::Real, q::Real)\n\nComputes the Wigner function of the density matrix ρ at the point (p,q).\n\njulia> using Printf\n\njulia> alpha = 0.25;\n\njulia> hspace_size = 8;\n\njulia> Ψ = coherent(alpha, hspace_size);\n\njulia> prob = wigner(ket2dm(Ψ), 0, 0);\n\njulia> @printf \"prob: %.6f\" prob\nprob: -0.561815\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.moyal","page":"Library","title":"Qanuk.moyal","text":"moyal(m, n)\n\nReturns the Moyal function w_mn(eta) for Fock states m and n.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.genlaguerre","page":"Library","title":"Qanuk.genlaguerre","text":"genlaguerre(x, alpha, n)\n\nReturns the generalized Laguerre polynomial of degree n for x using a recursive method. See https://en.wikipedia.org/wiki/Laguerre_polynomials.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.get_embed_operator","page":"Library","title":"Qanuk.get_embed_operator","text":"get_embed_operator(op::DenseOperator, target_body_index::Int, system::MultiBodySystem)\n\nUses a local operator (op), which is defined for a particular body (e.g. qubit) with index target_body_index, to build the corresponding operator for the Hilbert space of the multi-body system given by system. \n\nExamples\n\njulia> system = MultiBodySystem(3,2)\nQanuk.Multibody system with 3 bodies\n   Hilbert space structure:\n   [2, 2, 2]\n\njulia> x = sigma_x()\n(2,2)-element Qanuk.AntiDiagonalOperator:\nUnderlying data type: ComplexF64:\n    .    1.0 + 0.0im\n    1.0 + 0.0im    .\n\njulia> X_1=get_embed_operator(x,1,system)\n(8, 8)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.get_num_qubits-Tuple{AbstractOperator}","page":"Library","title":"Qanuk.get_num_qubits","text":"get_num_qubits(x::AbstractOperator)\n\nReturns the number of qubits associated with an Operator.\n\nExamples\n\njulia> ρ = DenseOperator([1. 0.\n                     0. 0.])\n(2, 2)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im\n\njulia> get_num_qubits(ρ)\n1\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Qanuk.get_num_qubits-Tuple{Union{Bra, Ket}}","page":"Library","title":"Qanuk.get_num_qubits","text":"get_num_qubits(x::Union{Ket, Bra})\n\nReturns the number of qubits associated with a Ket or a Bra.\n\nExamples\n\njulia> ψ = Ket([1., 0., 0., 0.])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_num_qubits(ψ)\n2\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Qanuk.get_num_bodies","page":"Library","title":"Qanuk.get_num_bodies","text":"get_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with an Operator given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ρ = DenseOperator([1. 0. 0.\n                     0. 0. 0.\n                     0. 0. 0.])\n(3, 3)-element Qanuk.DenseOperator:\nUnderlying data ComplexF64:\n1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im\n\njulia> get_num_bodies(ρ, 3)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.get_num_bodies-2","page":"Library","title":"Qanuk.get_num_bodies","text":"get_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)\n\nReturns the number of bodies associated with a Ket or a Bra given the hilbert_space_size_per_body.\n\nExamples\n\njulia> ψ = Ket([1., 0., 0., 0., 0., 0., 0., 0., 0.])\n9-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> get_num_bodies(ψ, 3)\n2\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.fock","page":"Library","title":"Qanuk.fock","text":"fock(i, hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the ith Fock basis of a Hilbert space with size hspace_size as a Ket.\n\nThe Ket contains values of type T, which by default is ComplexF64.\n\nExamples\n\njulia> ψ = fock(0, 3)\n3-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ = fock(1, 3)\n3-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n0.0 + 0.0im\n\n\njulia> ψ = fock(1, 3,ComplexF32) # specifying a type other than ComplexF64\n3-element Ket{ComplexF32}:\n0.0f0 + 0.0f0im\n1.0f0 + 0.0f0im\n0.0f0 + 0.0f0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.spin_up","page":"Library","title":"Qanuk.spin_up","text":"spin_up(T::Type{<:Complex}=ComplexF64)\n\nReturns the Ket representation of the spin-up state.\n\nThe Ket stores values of type T, which is ComplexF64 by default.\n\nExamples\n\njulia> ψ = spin_up()\n2-element Ket{ComplexF64}:\n1.0 + 0.0im\n0.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.spin_down","page":"Library","title":"Qanuk.spin_down","text":"spin_down(T::Type{<:Complex}=ComplexF64)\n\nReturns the Ket representation of the spin-down state.\n\nThe Ket stores values of type T, which is ComplexF64 by default.\n\nExamples\n\njulia> ψ = spin_down()\n2-element Ket{ComplexF64}:\n0.0 + 0.0im\n1.0 + 0.0im\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.create","page":"Library","title":"Qanuk.create","text":"create(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the bosonic creation operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.destroy","page":"Library","title":"Qanuk.destroy","text":"destroy(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the bosonic annhilation operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.number_op","page":"Library","title":"Qanuk.number_op","text":"number_op(hspace_size,T::Type{<:Complex}=ComplexF64)\n\nReturns the number operator for a Fock space of size hspace_size, of default type ComplexF64.\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.coherent","page":"Library","title":"Qanuk.coherent","text":"coherent(alpha, hspace_size)\n\nReturns a coherent state for the parameter alpha in a Fock space of size hspace_size. Note that |alpha|^2 is equal to the photon number of the coherent state. \n\n# Examples\n\njulia> ψ = coherent(2.0,20)\n20-element Ket{ComplexF64}:\n0.1353352832366127 + 0.0im\n0.2706705664732254 + 0.0im\n0.3827859860416437 + 0.0im\n0.44200318416631873 + 0.0im\n0.44200318416631873 + 0.0im\n0.3953396664268989 + 0.0im\n0.3227934859426707 + 0.0im\n0.24400893961026582 + 0.0im\n0.17254037586855772 + 0.0im\n0.11502691724570517 + 0.0im\n0.07274941014482605 + 0.0im\n0.043869544940011405 + 0.0im\n0.025328093580341972 + 0.0im\n0.014049498479026656 + 0.0im\n0.007509772823502764 + 0.0im\n0.003878030010563634 + 0.0im\n0.001939015005281817 + 0.0im\n0.000940560432521708 + 0.0im\n0.0004433844399679012 + 0.0im\n0.00020343873336404819 + 0.0im\n\n\njulia> expected_value(number_op(20),ψ)\n3.99999979364864 + 0.0im\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.ShrodingerProblem","page":"Library","title":"Qanuk.ShrodingerProblem","text":"ShrodingerProblem is a structure that is defined to solve the shrodinger equation in time-domain using sesolve().\n\nFields\n\nH – a function that retrurns the  Hamiltonian operator (of any subtype of AbstractOperator) as a function of time.\ninit_state – initital state (Ket) of a quantum system\ntspan – time interval for which the system has to be simulated.        For instance:            tspan=(0.0,1.0) evaluates the output from t=0.0 to t=1.0\ne_ops – list of operators for which the expected value    (the observables) will be evaluated at each time step in t_range. \n\n\n\n\n\n","category":"type"},{"location":"library.html#Qanuk.LindbladProblem","page":"Library","title":"Qanuk.LindbladProblem","text":"A LindbladProblem is a structure that is defined to solve the Lindblad master equation in time-domain using lindblad_solve().\n\nFields\n\nH – a function that retrurns the  Hamiltonian operator (of any subtype of AbstractOperator) as a function of time.\ninit_state – initital state density matrix (DenseOperator) of a quantum system\ntspan – time interval for which the system has to be simulated.        For instance:            tspan=(0.0,1.0) evaluates the output from t=0.0 to t=1.0\ne_ops – list of operators (type DenseOperator) for which the expected value    (the observables) will be evaluated at each time step in t_range. \nc_ops – list of collapse operators (type DenseOperator). \n\n\n\n\n\n","category":"type"},{"location":"library.html#Qanuk.sesolve","page":"Library","title":"Qanuk.sesolve","text":"sesolve(problem::ShrodingerProblem; kwargs...)\n\nSolves the Shrodinger equation:\n\nfracd Psid t=-i hatHPsi\n\nand returns a tuple correponding the time instance vector, the corresponding wavefunction Ket, and a Vector of observables evaluated at each time step. \n\nFields\n\nproblem – An object of type ShrodingerProblem that defines the problem to be solved. \nis_hamiltonian_static – A Bool variable indicating whether the Hamiltonian operator changes with time or not. Default value is false. If true, the solver can have significant performance boost.\nkwargs – list of keyword arguments to be passed to the ODE solver. See (https://docs.sciml.ai/DiffEqDocs/stable/basics/commonsolveropts/#solver_options).\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.lindblad_solve","page":"Library","title":"Qanuk.lindblad_solve","text":"    lindblad_solve(problem::LindbladProblem;kwargs...)\n\nSolves the Lindblad Master equation:\n\ndotrho=-i H rho+sum_i gamma_ileft(L_i rho L^dag_i - frac12leftL^dag_i L_i rhorightright)\n\nand returns a Vector of observables evaluated at each time step.\n\nFields\n\nproblem – An object of type LindbladProblem that defines the problem to be solved. \nkwargs – list of keyword arguments to be passed to the ODE solver. See (https://docs.sciml.ai/DiffEqDocs/stable/basics/commonsolveropts/#solver_options)..\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.compare_kets","page":"Library","title":"Qanuk.compare_kets","text":"compare_kets(ψ_0::Ket,ψ_1::Ket)\n\nChecks for equivalence allowing for a global phase difference between two input kets.\n\nExamples\n\njulia> ψ_0 = Ket([1.,2.,3.,4.])\n4-element Ket{ComplexF64}:\n1.0 + 0.0im\n2.0 + 0.0im\n3.0 + 0.0im\n4.0 + 0.0im\n\n\njulia> δ=π/3 # phase offset\n1.0471975511965976\n\njulia> ψ_1 = exp(im*δ)*ψ_0\n4-element Ket{ComplexF64}:\n0.5000000000000001 + 0.8660254037844386im\n1.0000000000000002 + 1.7320508075688772im\n1.5000000000000004 + 2.598076211353316im\n2.0000000000000004 + 3.4641016151377544im\n\n\njulia> compare_kets(ψ_0,ψ_1)\ntrue\n\njulia> apply_gate!(ψ_1,sigma_x(1))\n\njulia> compare_kets(ψ_0,ψ_1) # no longer equivalent after SigmaX gate\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Visualization","page":"Library","title":"Visualization","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"The QanukPlots package provides multiple visualization tools for Qanuk.jl. Please see the documentation of QanukPlots for more details. ","category":"page"},{"location":"library.html#Pauli-Simulator","page":"Library","title":"Pauli Simulator","text":"","category":"section"},{"location":"library.html","page":"Library","title":"Library","text":"Qanuk provides tools for the efficient storage and manipulation of Pauli group elements.","category":"page"},{"location":"library.html","page":"Library","title":"Library","text":"Qanuk.PauliGroupElement\nget_pauli\nBase.:*(p1::Qanuk.PauliGroupElement, p2::Qanuk.PauliGroupElement)\nget_quantum_circuit\nget_negative_exponent\nget_imaginary_exponent","category":"page"},{"location":"library.html#Qanuk.PauliGroupElement","page":"Library","title":"Qanuk.PauliGroupElement","text":"PauliGroupElement\n\nA Pauli group element which is represented using the approach of Dehaene and De Moor (2003).\n\nThe get_pauli functions should be used to generate PauliGroupElement objects.\n\n\n\n\n\n","category":"type"},{"location":"library.html#Qanuk.get_pauli","page":"Library","title":"Qanuk.get_pauli","text":"get_pauli(circuit::QuantumCircuit; imaginary_exponent::Integer=0,\n    negative_exponent::Integer=0)::PauliGroupElement\n\nReturns a PauliGroupElement given a circuit containing Pauli gates.\n\nA Pauli group element corresponds to i^delta (-1)^epsilon sigma_a, where delta and epsilon are set by specifying imaginary_exponent and negative_exponent, respectively. The exponents must be 0 or 1. Their default value is 0. As for sigma_a, it is a tensor product of Pauli operators. The Pauli operators are specified in the circuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count=2);\n\njulia> push!(circuit, sigma_x(1), sigma_y(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\njulia> get_pauli(circuit, imaginary_exponent=1, negative_exponent=1)\nPauli Group Element:\n-1.0im*X(1)*Y(2)\n\n\n\n\nIf multiple Pauli gates are applied to the same qubit in the circuit, the gates are multiplied with the first gate in the circuit being the rightmost gate in the multiplication.\n\njulia> circuit = QuantumCircuit(qubit_count=1);\n\njulia> push!(circuit, sigma_x(1), sigma_z(1))\nQuantum Circuit Object:\n   qubit_count: 1 \nq[1]:──X────Z──\n               \n\n\n\njulia> get_pauli(circuit)\nPauli Group Element:\n1.0im*Y(1)\n\n\n\n\n\n\n\n\nget_pauli(gate::AbstractGate, num_qubits::Integer; imaginary_exponent::Integer=0,\n    negative_exponent::Integer=0)::PauliGroupElement\n\nReturns a PauliGroupElement given a gate and the number of qubits.\n\nA Pauli group element corresponds to i^delta (-1)^epsilon sigma_a, where delta and epsilon are set by specifying imaginary_exponent and negative_exponent, respectively. The exponents must be 0 or 1. Their default value is 0. As for sigma_a, it is a tensor product of Pauli operators. In this variant of the get_pauli function, a single Pauli operator is set by providing a gate. The number of qubits is specified by num_qubits.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> get_pauli(gate, num_qubits)\nPauli Group Element:\n1.0*X(2)\n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Base.:*-Tuple{Qanuk.PauliGroupElement, Qanuk.PauliGroupElement}","page":"Library","title":"Base.:*","text":"Base.:*(p1::PauliGroupElement, p2::PauliGroupElement)::PauliGroupElement\n\nReturns the product of two PauliGroupElement objects.\n\nThe PauliGroupElement objects must be associated with the same number of qubits.\n\nExamples\n\njulia> pauli_z = get_pauli(sigma_z(1), 1)\nPauli Group Element:\n1.0*Z(1)\n\n\n\njulia> pauli_y = get_pauli(sigma_y(1), 1)\nPauli Group Element:\n1.0*Y(1)\n\n\n\njulia> pauli_z*pauli_y\nPauli Group Element:\n-1.0im*X(1)\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"library.html#Qanuk.get_quantum_circuit","page":"Library","title":"Qanuk.get_quantum_circuit","text":"get_quantum_circuit(pauli::PauliGroupElement)::QuantumCircuit\n\nReturns the Pauli gates of a PauliGroupElement as a QuantumCircuit.\n\nExamples\n\njulia> circuit = QuantumCircuit(qubit_count=2);\n\njulia> push!(circuit, sigma_x(1), sigma_y(2))\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\njulia> pauli = get_pauli(circuit, imaginary_exponent=1, negative_exponent=1)\nPauli Group Element:\n-1.0im*X(1)*Y(2)\n\n\n\njulia> get_quantum_circuit(pauli)\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──X───────\n               \nq[2]:───────Y──\n               \n\n\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.get_negative_exponent","page":"Library","title":"Qanuk.get_negative_exponent","text":"get_negative_exponent(pauli::PauliGroupElement)::Int\n\nReturns the negative exponent of a PauliGroupElement.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> pauli = get_pauli(gate, num_qubits, negative_exponent=1)\nPauli Group Element:\n-1.0*X(2)\n\n\n\njulia> get_negative_exponent(pauli)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html#Qanuk.get_imaginary_exponent","page":"Library","title":"Qanuk.get_imaginary_exponent","text":"get_imaginary_exponent(pauli::PauliGroupElement)::Int\n\nReturns the imaginary exponent of a PauliGroupElement.\n\nExamples\n\njulia> gate = sigma_x(2);\n\njulia> num_qubits = 3;\n\njulia> pauli = get_pauli(gate, num_qubits, imaginary_exponent=1)\nPauli Group Element:\n1.0im*X(2)\n\n\n\njulia> get_imaginary_exponent(pauli)\n1\n\n\n\n\n\n\n","category":"function"},{"location":"library.html","page":"Library","title":"Library","text":"DocTestSetup = nothing","category":"page"},{"location":"development.html#Qanuk-development","page":"Developing","title":"Qanuk development","text":"","category":"section"},{"location":"development.html#Installing-Qanuk-for-local-development","page":"Developing","title":"Installing Qanuk for local development","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"When developing Qanuk, you must ensure that you are using a local copy of Qanuk, not the latest released version. The easiest way to achieve that is to set the project to the local directory.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If you are starting a new instance of Julia, then you can activate the Qanuk project with","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Or, if you are inside a script or REPL, you can use","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.activate(\".\")","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If the current directory is not the Qanuk project, replace . with the Qanuk project path.","category":"page"},{"location":"development.html#Running-tests","page":"Developing","title":"Running tests","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"First open a julia REPL in the current project","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"and run the tests","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.test()","category":"page"},{"location":"development.html#Build-the-documentation","page":"Developing","title":"Build the documentation","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"First open a julia REPL using the docs project","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=./docs","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"If it is the first time building the docs, you need to instantiate the Julia project and add the Qanuk project as a development dependency. This means the version of the Qanuk package loaded is the one at the path specified, pwd(), and not the one registered at JuliaHub.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"using Pkg\nPkg.develop(PackageSpec(path=pwd()))\nPkg.instantiate()","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"At which point, the project status should be similar to the one below. The versions might be slightly different, but what is important is that the Status line refers to the docs/Project.toml and that Qanuk refers to <pwd()>/Qanuk.jl.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Pkg.status()\n\n# output\n      Status `<pwd()>/Qanuk.jl/docs/Project.toml`\n  [e30172f5] Documenter v0.27.24\n  [cd3eb016] HTTP v1.7.4\n  [682c06a0] JSON v0.21.4\n  [7bd9edc1] Qanuk v0.1.0 `<pwd()>/Qanuk.jl`\n  [90137ffa] StaticArrays v1.5.21\n  [2913bbd2] StatsBase v0.33.21\n  [de0858da] Printf","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Then you can run","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"include(\"./docs/make.jl\")","category":"page"},{"location":"development.html#Run-coverage-locally","page":"Developing","title":"Run coverage locally","text":"","category":"section"},{"location":"development.html","page":"Developing","title":"Developing","text":"If you haven't already, instantiate the project with Julia's package manager.","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=. -e 'using Pkg; Pkg.Instantiate()'","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":".","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"You can run coverage locally from the project directory using","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"julia --project=. coverage.jl","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"The script returns the covered and total line as output. An example output is shown below","category":"page"},{"location":"development.html","page":"Developing","title":"Developing","text":"Covered lines: 1373\nTotal lines: 1383\nCoverage percentage: 0.9927693420101229","category":"page"},{"location":"tutorials/basics.html#Basic-Concepts","page":"Basics","title":"Basic Concepts","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"In this tutorial, we introduce basic concepts and objects that are used in Qanuk. ","category":"page"},{"location":"tutorials/basics.html#Quantum-Circuits","page":"Basics","title":"Quantum Circuits","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"In quantum computing, a quantum circuit represents a sequence of operations that are intended to be applied to qubits.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Let's start by an example.  We are going to start by importing Qanuk.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"using Qanuk","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We can then create an empty quantum circuit by specifying the number of qubits the circuit will involve:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"c=QuantumCircuit(qubit_count=2)","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"At anypoint, you can visualize a QuantumCircuit object by simply printing it:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"print(c)\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:\n     \nq[2]:\n     \n","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We have not yet added any quantum operation to our circuit and it looks empty! So, let's make this circuit a bit more interesting.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"note: Note\nIn Qanuk, we assume all qubits are initialized to be in state 0 (ground state). ","category":"page"},{"location":"tutorials/basics.html#Quantum-Gates","page":"Basics","title":"Quantum Gates","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Basic logical operations on qubits are commonly called quantum logic gates or simply gates. We will quite often talk about single-qubit gates, two-qubit gates or multiple-qubit gates in quantum information theory.","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Let's start by adding a gate called the Hadamard gate to our circuit, c, and specify that it will only operate on qubit '1'. We will do so by calling the push! function:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"push!(c,hadamard(1))","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"note: Note\nUnlike C++ or Python, indexing in Julia starts from \"1\" and not \"0\"!","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Note the exclamation mark at the end of push! which emphasizes the fact that we have called a mutating function that will change the argument c (our quantum circuit). ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"If we now print circuit c, we will see the following output","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"print(c)\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H──\n          \nq[2]:─────\n","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Now let's add a famous two-qubit gate, control_x, also known as the CNOT gate in the quantum information community: ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"push!(c,control_x(1,2))\n# output\nQuantum Circuit Object:\n   qubit_count: 2 \nq[1]:──H────*──\n            |  \nq[2]:───────X──\n               ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"Voila! You just made your first quantum circuit with Qanuk that does something interesting:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"It puts a two-qubit register in a maximally-entangled quantum state (fracleft00rightrangle+left11rightranglesqrt2). This sate is one of the four celebrated  Bell State or the EPR states. These states do not have classical counterparts and are are among the building blocks of many interesting ideas in quantum computing and quantum communication.","category":"page"},{"location":"tutorials/basics.html#Circuit-Simulation","page":"Basics","title":"Circuit Simulation","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"You can verify what your circuit will ideally do on a real computer by simulating the circuit on your own local machine:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"simulate(c)\n# output\n4-element Ket{ComplexF64}:\n0.7071067811865475 + 0.0im\n0.0 + 0.0im\n0.0 + 0.0im\n0.7071067811865475 + 0.0im","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"The output of simulate function is a Ket object. Ket is a complex vector that represents the wavefunction of a quantum object such as our two-qubit system. ","category":"page"},{"location":"tutorials/basics.html#Histogram","page":"Basics","title":"Histogram","text":"","category":"section"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"In the previous section, we used the simulate function to calculate the wavefunction of a two-qubit quantum register, after the circuit, c, is applied to it. However, in the real world, we do not have direct access to the wavefunction of a quantum register. Rather, we need to run the quantum circuit many many times (shots) on the quantum processor and measure the qubits states at the end of each shot. The result of each shot is a bitstring that tells us which qubits were measured to be in state 0 and which qubits were measured to be in state 1. The probability of getting a bitstring then depends on the wavefunction. ","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"We can indeed mimick this behaviour in our simulations as well.  This can be achieved by using the plot_histogram function from the SnowflakePlots library.  For example, we can generate a histogram which shows the measurement output distribution after taking running the circuit c for a given number of shots, let's say 100 times, on a quantum computer simulator:","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"using SnowflakePlots\nplot_histogram(c, 100)","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"(Image: Measurement results histogram)","category":"page"},{"location":"tutorials/basics.html","page":"Basics","title":"Basics","text":"In the next tutorial, we will discuss how to run the above circuit on a real quantum processor. ","category":"page"},{"location":"tutorials/run_circuit.html#Run-a-circuit-on-a-QPU","page":"Run a circuit","title":"Run a circuit on a QPU","text":"","category":"section"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"In the previous tutorial, we introduced some basics concept of quantum computing, namely the quantum circuit and quantum gates. ","category":"page"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"We also learnt how to build a quantum circuit using Qanuk and simulate the result of such circuit using our local machine. ","category":"page"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"In this tutorial, we will the steps involved in running a quantum circuit on a both a virtual and also a real Quantum Processing Unit (QPU). ","category":"page"},{"location":"tutorials/run_circuit.html#QPU-Object","page":"Run a circuit","title":"QPU Object","text":"","category":"section"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"Interactions with different QPUs are facilitated using structs (objects) that represent QPU hardware.  These structures are used to implement a harmonized interface, and are derived from an abstract type called AbstractQPU. This interface gives you a unified way to write code that is agnostic of the quantum service you are using. The interface dictates how to get metadata about the QPU, how to run a quantum circuit on the QPU, and more. ","category":"page"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"warning: Warning\nYou should not use AbstractQPU, rather use a QPU object which is derived from AbstractQPU. For further details on the implemented derived QPUs, see the Library page. ","category":"page"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"Now that you know what QPU objects are, let's get started by importing Qanuk:","category":"page"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"using Qanuk","category":"page"},{"location":"tutorials/run_circuit.html#Virtual-QPU","page":"Run a circuit","title":"Virtual QPU","text":"","category":"section"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"Next, we are going to create a QPU object to represent a virtual QPU to be run on our local machine:","category":"page"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"qpu_v=VirtualQPU()","category":"page"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"We can print QPU's meta data by simply using","category":"page"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"print(qpu_v)\n# output\nQuantum Simulator:\n   developers:  Anyon Systems Inc.\n   package:     Qanuk.jl\n","category":"page"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"or alternatively, retrieve the QPU metadata in a Dict{String,String} format through the following command:","category":"page"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"get_metadata(qpu_v)\n# output\nDict{String, String} with 2 entries:\n  \"developers\" => \"Anyon Systems Inc.\"\n  \"package\"    => \"Qanuk.jl\"\n\n","category":"page"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"Now, let's create a circuit to create a Bell pair as was explained in the previous tutorial:","category":"page"},{"location":"tutorials/run_circuit.html","page":"Run a circuit","title":"Run a circuit","text":"c=QuantumCircuit(qubit_count=2)\npush!(c,hadamard(1),control_x(1,2))","category":"page"},{"location":"index.html#Snowflake.jl","page":"Home","title":"Snowflake.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"DocTestSetup = :(using Snowflake)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A library for quantum computing using Julia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Snowflake is a pure Julia quantum computing stack that allows you to easily design quantum circuits, experiments and algorithms. Snowflake can run these quantum applications on real quantum computers or classical simulators.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"warning: Warning\nSnowflake has yet to reach version 1.0, but we intend to keep compatibility with what is documented here. We will only make a breaking change if something is broken. After version 1.0, the public API will be stable and only change with major releases.","category":"page"},{"location":"index.html#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The following installation steps are for people interested in using Snowflake in their own applications. If you are interested in helping to develop Snowflake, head right over to our Developing Snowflake page.","category":"page"},{"location":"index.html#Installing-Julia","page":"Home","title":"Installing Julia","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Make sure your system has Julia installed. If not, download the latest version from https://julialang.org/downloads/.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We officially support the latest stable release and the latest Long-term support release. Any release in-between should work (please file a bug if they don't), but we only actively test against the LTS and the latest stable version.","category":"page"},{"location":"index.html#Installing-the-Snowflake-package","page":"Home","title":"Installing the Snowflake package","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Snowflake is still in pre-release phase. Therefore, and for the time being, we recommand installing it by checking out the main branch from github. This can be achieved by typing the following commands in the Julia REPL:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/anyonlabs/Snowflake.jl\", rev=\"main\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This will add the Snowflake package to the current Julia Environment.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Once Snowflake.jl is released, you can install the latest release using the following command","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"import Pkg\nPkg.add(\"Snowflake\")","category":"page"},{"location":"index.html#Installing-the-SnowflakePlots-package","page":"Home","title":"Installing the SnowflakePlots package","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Multiple visualization tools are available in the SnowflakePlots package. After installing Snowflake, the SnowflakePlots package can be installed by entering the following in the Julia REPL:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/anyonlabs/SnowflakePlots.jl\", rev=\"main\")","category":"page"}]
}
