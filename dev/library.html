<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · Qanuk</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Qanuk logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Qanuk</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="getting_started.html">Getting Started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="tutorials/basics.html">Basics</a></li><li><a class="tocitem" href="tutorials/run_circuit.html">Run a circuit</a></li></ul></li><li class="is-active"><a class="tocitem" href="library.html">Library</a><ul class="internal"><li><a class="tocitem" href="#Quantum-Circuit"><span>Quantum Circuit</span></a></li><li><a class="tocitem" href="#Quantum-Gates"><span>Quantum Gates</span></a></li><li><a class="tocitem" href="#Quantum-Processing-Unit"><span>Quantum Processing Unit</span></a></li><li><a class="tocitem" href="#Quantum-Toolkit"><span>Quantum Toolkit</span></a></li><li><a class="tocitem" href="#Pauli-Simulator"><span>Pauli Simulator</span></a></li></ul></li><li><a class="tocitem" href="development.html">Developing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="library.html">Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="library.html">Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/anyonlabs/Qanuk.jl/blob/main/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="Quantum-Circuit"><a class="docs-heading-anchor" href="#Quantum-Circuit">Quantum Circuit</a><a id="Quantum-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Circuit" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qanuk.QuantumCircuit" href="#Qanuk.QuantumCircuit"><code>Qanuk.QuantumCircuit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuantumCircuit(qubit_count)</code></pre><p>A data structure to represent a <em>quantum circuit</em>.  </p><p><strong>Fields</strong></p><ul><li><code>qubit_count::Int</code> – number of qubits (i.e. quantum register size).</li><li><code>gates::Vector{AbstractGate}</code> – the sequence of gates to operate on qubits.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">push!(circuit::QuantumCircuit, gates::AbstractGate...)</code></pre><p>Inserts one or more <code>gates</code> at the end of a <code>circuit</code>.</p><p>A <code>Vector</code> of <code>AbstractGate</code> objects can be passed to this function by using splatting. More details about splatting are provided <a href="https://docs.julialang.org/en/v1/manual/faq/#What-does-the-...-operator-do?">here</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────X────X──
                    



julia&gt; gate_list = [sigma_x(1), hadamard(2)];

julia&gt; push!(c, gate_list...)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*────X───────
                 |            
q[2]:───────X────X─────────H──
                              


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L40-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pop!" href="#Base.pop!"><code>Base.pop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pop!(circuit::QuantumCircuit)</code></pre><p>Removes the last gate from <code>circuit.gates</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────X────X──
                    



julia&gt; pop!(c)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L442-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">append!(base_circuit::QuantumCircuit, circuits_to_append::QuantumCircuit...)</code></pre><p>Appends one or more <code>circuits_to_append</code> to the <code>base_circuit</code>.</p><p>The <code>circuits_to_append</code> cannot contain more qubits than the <code>base_circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; base = QuantumCircuit(qubit_count=2, gates=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; append_1 = QuantumCircuit(qubit_count=1, gates=[sigma_z(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──Z──
          



julia&gt; append_2 = QuantumCircuit(qubit_count=2, gates=[control_x(1,2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──*──
       |  
q[2]:──X──
          



julia&gt; append!(base, append_1, append_2)

julia&gt; print(base)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X────Z────*──
                 |  
q[2]:────────────X──
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L95-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prepend!" href="#Base.prepend!"><code>Base.prepend!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prepend!(base_circuit::QuantumCircuit, circuits_to_prepend::QuantumCircuit...)</code></pre><p>Prepends one or more <code>circuits_to_prepend</code> to the <code>base_circuit</code>.</p><p>The order of the <code>circuits_to_prepend</code> is maintained (i.e. <code>circuits_to_prepend[1]</code> will appear leftmost in <code>base_circuit</code>). The <code>circuits_to_prepend</code> cannot contain more qubits than the <code>base_circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; base = QuantumCircuit(qubit_count=2, gates=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; prepend_1 = QuantumCircuit(qubit_count=1, gates=[sigma_z(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──Z──
          



julia&gt; prepend_2 = QuantumCircuit(qubit_count=2, gates=[control_x(1,2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──*──
       |  
q[2]:──X──
          



julia&gt; prepend!(base, prepend_1, prepend_2)

julia&gt; print(base)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z────*────X──
            |       
q[2]:───────X───────
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L157-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.simulate" href="#Qanuk.simulate"><code>Qanuk.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate(circuit::QuantumCircuit)</code></pre><p>Simulates and returns the wavefunction of the quantum device after running <code>circuit</code>,  assuming an initial state Ket ψ corresponding to the 0th Fock basis, i.e.:  <code>ψ=fock(0,2^get_num_qubits(circuit))</code>. </p><p>Employs the approach described in Listing 5 of <a href="https://doi.org/10.22331/q-2021-10-06-559">Suzuki <em>et. al.</em> (2021)</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H──
          
q[2]:─────
          


julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H────*──
            |  
q[2]:───────X──
               


julia&gt; ket = simulate(c)
4-element Ket{ComplexF64}:
0.7071067811865475 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.7071067811865475 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L641-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.simulate_shots" href="#Qanuk.simulate_shots"><code>Qanuk.simulate_shots</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate_shots(c::QuantumCircuit, shots_count::Int = 100)</code></pre><p>Emulates a quantum computer by running a circuit for a given number of shots and returning measurement results.  The distribution of measured states corresponds to the coefficients in the resulting state Ket. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2);

julia&gt; push!(c, hadamard(1))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H──
          
q[2]:─────
          


julia&gt; push!(c, control_x(1,2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H────*──
            |  
q[2]:───────X──
               


julia&gt; simulate_shots(c, 99)
99-element Vector{String}:
 &quot;11&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 ⋮
 &quot;00&quot;
 &quot;00&quot;
 &quot;11&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;
 &quot;00&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L693-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_measurement_probabilities-Tuple{QuantumCircuit}" href="#Qanuk.get_measurement_probabilities-Tuple{QuantumCircuit}"><code>Qanuk.get_measurement_probabilities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_measurement_probabilities(circuit::QuantumCircuit,
    [target_qubits::Vector{&lt;:Integer}])::AbstractVector{&lt;:Real}</code></pre><p>Returns a vector listing the measurement probabilities for the <code>target_qubits</code> in the <code>circuit</code>.</p><p>If no <code>target_qubits</code> are provided, the probabilities are computed for all the qubits.</p><p>The measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit <code>QuantumCircuit</code>, the probabilities are listed for 00, 01, 10, and 11.</p><p><strong>Examples</strong></p><p>The following example constructs a <code>QuantumCircuit</code> where the probability of measuring 01 is 50% and the probability of measuring 11 is also 50%.</p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count=2);

julia&gt; push!(circuit, hadamard(1), sigma_x(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H───────
               
q[2]:───────X──
               



julia&gt; get_measurement_probabilities(circuit)
4-element Vector{Float64}:
 0.0
 0.4999999999999999
 0.0
 0.4999999999999999
</code></pre><p>For the same <code>circuit</code>, the probability of measuring qubit 2 and finding 1 is 100%.</p><pre><code class="language-julia-repl hljs">julia&gt; target_qubit = [2];

julia&gt; get_measurement_probabilities(circuit, target_qubit)
2-element Vector{Float64}:
 0.0
 0.9999999999999998
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L767-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{QuantumCircuit}" href="#Base.inv-Tuple{QuantumCircuit}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(circuit::QuantumCircuit)</code></pre><p>Return a <code>QuantumCircuit</code> which is the inverse of the input <code>circuit</code>.  Each gate is replaced by it&#39;s corresponding inverse, and the order of gates is reversed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=2);

julia&gt; push!(c, rotation_y(1, pi/4));

julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Ry(0.7854)────*──
                     |  
q[2]:────────────────X──
                        



julia&gt; inv(c)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──*────Ry(-0.7854)──
       |                 
q[2]:──X─────────────────
                         


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L826-L859">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_num_gates_per_type" href="#Qanuk.get_num_gates_per_type"><code>Qanuk.get_num_gates_per_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_gates_per_type(circuit::QuantumCircuit)::AbstractDict{&lt;:AbstractString, &lt;:Integer}</code></pre><p>Returns a dictionary listing the number of gates of each type found in the <code>circuit</code>.</p><p>The dictionary keys are the instruction_symbol of the gates while the values are the number of gates found.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=2);

julia&gt; push!(c, hadamard(1), hadamard(2));

julia&gt; push!(c, control_x(1, 2));

julia&gt; push!(c, hadamard(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*───────
                 |       
q[2]:───────H────X────H──
                         



julia&gt; get_num_gates_per_type(c)
Dict{String, Int64} with 2 entries:
  &quot;h&quot;  =&gt; 3
  &quot;cx&quot; =&gt; 1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L870-L901">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_num_gates" href="#Qanuk.get_num_gates"><code>Qanuk.get_num_gates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_gates(circuit::QuantumCircuit)::Integer</code></pre><p>Returns the number of gates in the <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=2);

julia&gt; push!(c, hadamard(1), hadamard(2));

julia&gt; push!(c, control_x(1, 2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H─────────*──
                 |  
q[2]:───────H────X──
                    



julia&gt; get_num_gates(c)
3
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L915-L940">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.serialize_job" href="#Qanuk.serialize_job"><code>Qanuk.serialize_job</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">serialize_job(circuit::QuantumCircuit,repetitions::Integer)</code></pre><p>Creates a JSON-formatted String containing the circuit configuration to be sent  to a <code>QPU</code> service, along with the number of repetitions requested.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count = 2,gates=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; serialize_job(c,10)
&quot;{\&quot;num_repetitions\&quot;:10,\&quot;circuit\&quot;:{\&quot;operations\&quot;:[{\&quot;parameters\&quot;:{},\&quot;type\&quot;:\&quot;x\&quot;,\&quot;qubits\&quot;:[0]}]}}&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/anyon/qpu_interface.jl#L105-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.transpile" href="#Qanuk.transpile"><code>Qanuk.transpile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transpile(::CompressSingleQubitGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CompressSingleQubitGatesTranspiler</code> transpiler stage  which gathers all single-qubit gates sharing a common target in an input  circuit and combines them into single <code>Universal</code> gates in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state <code>Ket</code>  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CompressSingleQubitGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X────Y──
               
q[2]:──────────
               



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=3.1416,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      



julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────Y─────────P(1.0472)──
                                 
q[2]:────────────*───────────────
                 |               
q[3]:────────────X───────────────
                                 



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──U(θ=0.0000,ϕ=-2.0944,λ=0.0000)───────
                                            
q[2]:────────────────────────────────────*──
                                         |  
q[3]:────────────────────────────────────X──
                                            




julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L297-L363">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastSwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastSwapToCZGateTranspiler</code> transpiler stage which expands all Swap gates into <code>CZ</code> gates and single-qubit gates. The result of the input and output circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastSwapToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[swap(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──☒──
       |
q[2]:──☒──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:───────────*────Y_m90────────────*────Y_90─────────────*──────────
                |                     |                     |          
q[2]:──Y_m90────Z─────────────Y_90────Z────────────Y_m90────Z────Y_90──
                                              
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L393-L421">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastCXToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastCXToCZGateTranspiler</code> transpiler stage which expands all <code>CX</code> gates into <code>CZ</code> and <code>Hadamard</code> gates. The result of the input and output circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastCXToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[control_x(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──*──
       |
q[2]:──X──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2
q[1]:───────*───────
            |
q[2]:──H────Z────H──</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L452-L478">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastISwapToCZGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastISwapToCZGateTranspiler</code> transpiler stage which expands all <code>ISwap</code> gates into <code>CZ</code> gates and single-qubit gates. The result of the input and output circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastISwapToCZGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[iswap(1, 2)])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──x──
       |
q[2]:──x──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Y_m90─────────────*────Y_90─────────────*────Y_90──────────
                         |                     |                  
q[2]:───────────X_m90────Z────────────X_m90────Z────────────X_90──
                                                                  
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L514-L542">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastToffoliToCXGateTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastToffoliToCXGateTranspiler</code> transpiler stage which expands all Toffoli gates into <code>CX</code> gates and single-qubit gates. The result of the input and output circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastToffoliToCXGateTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 3, gates=[toffoli(1, 2, 3)])
Quantum Circuit Object:
   qubit_count: 3
q[1]:──*──
       |
q[2]:──*──
       |
q[3]:──X──

julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──────────────────*────────────────────*──────────────*─────────T──────────*──
                       |                    |              |                    |  
q[2]:───────*──────────|─────────*──────────|────T─────────X──────────────T†────X──
            |          |         |          |                                      
q[3]:──H────X────T†────X────T────X────T†────X─────────T─────────H──────────────────
                                                                                   
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L591-L623">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastToPhaseShiftAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastToPhaseShiftAndHalfRotationXTranspiler</code> transpiler stage  which converts all single-qubit gates in an input circuit and converts them  into combinations of <code>PhaseShift</code> and <code>RotationX</code> with angle π/2 in an output  circuit. For any gate in the input circuit, the number of gates in the  output varies between zero and 5. The result of the input and output  circuit on any arbitrary state <code>Ket</code> is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastToPhaseShiftAndHalfRotationXTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z────X_90────Z────X_m90──
                                                 
q[2]:───────────────────────────
                                                 



julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Y──
          
q[2]:─────
          



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z_90────X_90────Z────X_m90────Z_90──
                                           
q[2]:──────────────────────────────────────
                                           



julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0.,0.,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      



julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L737-L818">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastUniversalToRzRxRzTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastUniversalToRzRxRzTranspiler</code> transpiler stage  which finds <code>Universal</code> gates in an input circuit and converst casts  them into a sequence of <code>PhaseShift</code> (Rz), <code>RotationX</code> (Rx) and  <code>PhaseShift</code> (Rz) gates in a new circuit. The result of the input and output circuit on any arbitrary state <code>Ket</code>  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastUniversalToRzRxRzTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,π/2,π/4,π/8)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=1.5708,ϕ=0.7854,λ=0.3927)──
                                      
q[2]:─────────────────────────────────
                                      

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(-1.1781)────Rx(1.5708)────P(2.3562)──
                                              
q[2]:─────────────────────────────────────────
                                              

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0,π/4,0)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.7854,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                      

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(-1.5708)────Rx(0.0000)────P(2.3562)──
                                              
q[2]:─────────────────────────────────────────
                                              
                                        
julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L871-L924">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CastRxToRzAndHalfRotationXTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CastRxToRzAndHalfRotationXTranspiler</code> transpiler stage  which finds <code>RotationX(θ)</code> gates in an input circuit and converts (casts)  them into a sequence of gates: <code>Z90</code>,<code>X90</code>,<code>PhaseShift(θ)</code>,<code>XM90</code>,<code>ZM90</code> in a new circuit. The result of the input and output circuit on any arbitrary state <code>Ket</code>  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CastRxToRzAndHalfRotationXTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,π/8)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(0.3927)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z_90────X_90────P(0.3927)────X_m90────Z_m90──
                                                    
q[2]:───────────────────────────────────────────────
                                                    

julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L972-L1005">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::SimplifyRxGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SimplifyRxGatesTranspiler</code> transpiler stage  which finds <code>RotationX</code> gates in an input circuit and according to it&#39;s  angle theta, casts them to one of the right-angle <code>RotationX</code> gates,  e.g. <code>SigmaX</code>, <code>X90</code>, or <code>XM90</code>. In the case where <code>theta≈0.</code>, the gate is removed. The result of the input and output circuit on any arbitrary state <code>Ket</code> is  unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=SimplifyRxGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,pi/2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(1.5708)──
                   
q[2]:──────────────
                   

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X_90──
             
q[2]:────────
             

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,pi)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(3.1416)──
                   
q[2]:──────────────
                   


julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X──
          
q[2]:─────
          

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[rotation_x(1,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Rx(0.0000)──
                   
q[2]:──────────────
                   


julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L1033-L1109">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::SwapQubitsForLineConnectivityTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SwapQubitsForLineConnectivityTranspiler</code> transpiler stage  which adds <code>Swap</code> gates around multi-qubit gates so that the  final <code>Operator</code> acts on adjacent qubits. The result of the input  and output circuit on any arbitrary state <code>Ket</code> is unchanged  (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=SwapQubitsForLineConnectivityTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 6, gates=[toffoli(4,6,1)])
Quantum Circuit Object:
   qubit_count: 6 
q[1]:──X──
       |  
q[2]:──|──
       |  
q[3]:──|──
       |  
q[4]:──*──
       |  
q[5]:──|──
       |  
q[6]:──*──
          




julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 6 
q[1]:───────────────────────────X───────────────────────────
                                |                           
q[2]:───────☒───────────────────*───────────────────☒───────
            |                   |                   |       
q[3]:──☒────☒──────────────☒────*────☒──────────────☒────☒──
       |                   |         |                   |  
q[4]:──☒──────────────☒────☒─────────☒────☒──────────────☒──
                      |                   |                 
q[5]:────────────☒────☒───────────────────☒────☒────────────
                 |                             |            
q[6]:────────────☒─────────────────────────────☒────────────
                                                            



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L1177-L1231">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::SimplifyRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SimplifyRzGatesTranspiler</code> transpiler stage  which finds <code>PhaseShift</code> gates in an input circuit and according to it&#39;s  phase angle phi, casts them to one of the right-angle <code>RotationZ</code> gates,  e.g. <code>SigmaZ</code>, <code>Z90</code>, <code>ZM90</code>, <code>Pi8</code> or <code>Pi8Dagger</code>. In the case where <code>phi≈0.</code>, the  gate is removed. The result of the input and output circuit on any  arbitrary state <code>Ket</code> is unchanged (up to a global phase). The tolerance  used for <code>Base.isapprox()</code> in each case can be set by passing an optional  argument to the <code>Transpiler</code>, e.g: <code>transpiler=SimplifyRzGatesTranspiler(1.0e-10)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=SimplifyRzGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,pi/2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(1.5708)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z_90──
             
q[2]:────────
             

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,pi)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(3.1416)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z──
          
q[2]:─────
          

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(0.0000)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:
     



julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L1289-L1366">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::CompressRzGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>CompressRzGatesTranspiler</code> transpiler stage  which gathers all Rz-type gates sharing a common target in an input  circuit and combines them into single PhaseShift gate in a new circuit. Gates ordering may differ when gates are applied to different qubits,  but the result of the input and output circuit on any arbitrary state <code>Ket</code>  is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=CompressRzGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_z(1),z_90(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z────Z_90──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(-1.5708)──
                   
q[2]:──────────────
                   

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_z(1),pi_8(1),control_x(2,3),z_minus_90(1)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──Z────T─────────Z_m90──
                             
q[2]:────────────*───────────
                 |           
q[3]:────────────X───────────
                             

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──P(2.3562)───────
                       
q[2]:───────────────*──
                    |  
q[3]:───────────────X──
                       

julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L1439-L1496">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::RemoveSwapBySwappingGates, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Removes the <code>Swap</code> gates from the <code>circuit</code> assuming all-to-all connectivity.</p><div class="admonition is-warning"><header class="admonition-header">The initial state must be the ground state!</header><div class="admonition-body"><p>This transpiler stage assumes that the input state is <span>$|0\rangle^{\otimes N}$</span> where <span>$N$</span> is the number of qubits. The stage should not be used on sub-circuits where the input state is not <span>$|0\rangle^{\otimes N}$</span>.</p></div></div><p>This transpiler stage eliminates <code>Swap</code> gates by moving the gates preceding each <code>Swap</code> gate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler = RemoveSwapBySwappingGates();

julia&gt; circuit = QuantumCircuit(qubit_count=2, gates=[hadamard(1), swap(1,2), sigma_x(2)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──H────☒───────
            |       
q[2]:───────☒────X──
                    



julia&gt; transpiled_circuit = transpile(transpiler, circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──────────
               
q[2]:──H────X──
               


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L1513-L1551">source</a></section><section><div><pre><code class="nohighlight hljs">transpile(::SimplifyTrivialGatesTranspiler, circuit::QuantumCircuit)::QuantumCircuit</code></pre><p>Implementation of the <code>SimplifyTrivialGatesTranspiler</code> transpiler stage  which finds gates which have no effect on the state Ket, such as Identity, and  parameterized gates with null parameters such as rotation_x(target, 0.). The result of the input and output circuit on any  arbitrary state Ket is unchanged (up to a global phase). The tolerance  used for Base.isapprox() in each case can be set by passing an optional  argument to the Transpiler, e.g: transpiler=SimplifyTrivialGatesTranspiler(1.0e-10)</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=SimplifyTrivialGatesTranspiler();

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[identity_gate(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──I──
          
q[2]:─────
          
julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit,transpiled_circuit)
true


julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[phase_shift(1,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──P(0.0000)──
                  
q[2]:─────────────
                  

julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit,transpiled_circuit)
true

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[universal(1,0.,0.,0.)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──U(θ=0.0000,ϕ=0.0000,λ=0.0000)──
                                      
q[2]:─────────────────────────────────
                                             
julia&gt; transpiled_circuit=transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:
     
q[2]:      

julia&gt; compare_circuits(circuit,transpiled_circuit)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L1630-L1700">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.compare_circuits" href="#Qanuk.compare_circuits"><code>Qanuk.compare_circuits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compare_circuits(c0::QuantumCircuit,c1::QuantumCircuit)::Bool</code></pre><p>Tests for equivalence of two circuits based on their effect on an  arbitrary input state (a Ket). Circuits are equivalent if they both  yield the same output for any input, up to a global phase. Circuits with different ordering of gates that apply on different  targets can also be equivalent.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c0 = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──X────Y──
               



julia&gt; c1 = QuantumCircuit(qubit_count = 1, gates=[phase_shift(1,π)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──P(3.1416)──
                  



julia&gt; compare_circuits(c0,c1)
true            

julia&gt; c0 = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────Y───────
                    
q[2]:────────────*──
                 |  
q[3]:────────────X──
                    



julia&gt; c1 = QuantumCircuit(qubit_count = 3, gates=[control_x(2,3),sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:───────X────Y──
                    
q[2]:──*────────────
       |            
q[3]:──X────────────
                    



julia&gt; compare_circuits(c0,c1)
true    
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L222-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.circuit_contains_gate_type" href="#Qanuk.circuit_contains_gate_type"><code>Qanuk.circuit_contains_gate_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">circuit_contains_gate_type(circuit::QuantumCircuit, gate_type::Type{&lt;:AbstractGate})::Bool</code></pre><p>Determined whether or not a type of gate is present in a circuit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count = 1, gates=[sigma_x(1),sigma_y(1)])
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──X────Y──
               
julia&gt; circuit_contains_gate_type(circuit, Qanuk.SigmaX)
true
               
julia&gt; circuit_contains_gate_type(circuit, Qanuk.ControlZ)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L305-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.permute_qubits!" href="#Qanuk.permute_qubits!"><code>Qanuk.permute_qubits!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permute_qubits!(circuit::QuantumCircuit,
    qubit_mapping::AbstractDict{T,T}) where T&lt;:Integer</code></pre><p>Modifies a <code>circuit</code> by moving the gates to other qubits based on a <code>qubit_mapping</code>.</p><p>The dictionary <code>qubit_mapping</code> contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.</p><p>For instance, <code>Dict(1=&gt;2)</code> is not a valid <code>qubit_mapping</code>, but <code>Dict(1=&gt;2, 2=&gt;1)</code> is valid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=3);

julia&gt; push!(c, sigma_x(1), hadamard(2), sigma_y(3))
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────────────
                    
q[2]:───────H───────
                    
q[3]:────────────Y──                    



julia&gt; permute_qubits!(c, Dict(1=&gt;3, 3=&gt;1))

julia&gt; show(c)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:────────────Y──
                    
q[2]:───────H───────
                    
q[3]:──X────────────
                    

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L943-L984">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.permute_qubits" href="#Qanuk.permute_qubits"><code>Qanuk.permute_qubits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">permute_qubits(circuit::QuantumCircuit,
    qubit_mapping::AbstractDict{T,T})::QuantumCircuit where T&lt;:Integer</code></pre><p>Returns a <code>QuantumCircuit</code> that is a copy of <code>circuit</code> but where the gates have been moved to other qubits based on a <code>qubit_mapping</code>.</p><p>The dictionary <code>qubit_mapping</code> contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit. All the keys in the dictionary must also be present as values and vice versa.</p><p>For instance, <code>Dict(1=&gt;2)</code> is not a valid <code>qubit_mapping</code>, but <code>Dict(1=&gt;2, 2=&gt;1)</code> is valid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = QuantumCircuit(qubit_count=3);

julia&gt; push!(c, sigma_x(1), hadamard(2), sigma_y(3))
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────────────
                    
q[2]:───────H───────
                    
q[3]:────────────Y──
                    



julia&gt; permute_qubits(c, Dict(1=&gt;3, 3=&gt;1))
Quantum Circuit Object:
   qubit_count: 3 
q[1]:────────────Y──
                    
q[2]:───────H───────
                    
q[3]:──X────────────
                    


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_circuit.jl#L1016-L1058">source</a></section></article><h2 id="Quantum-Gates"><a class="docs-heading-anchor" href="#Quantum-Gates">Quantum Gates</a><a id="Quantum-Gates-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Gates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qanuk.AbstractGate" href="#Qanuk.AbstractGate"><code>Qanuk.AbstractGate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGate</code></pre><p>A <code>Gate</code> is an instantiation of an <code>AbstractGate</code>, which can be added to a <code>QuantumCircuit</code> in order to apply an operator to one or more <code>target</code> qubits. <code>AbstractGate</code> is useful to dispatch all <code>Gates</code> to default implementation of functions such as get<em>connected</em>qubits().  Those functions are then specialized for <code>Gates</code> requiring a different implementation. </p><p><code>AbstractGate</code> is an abstract type, which means that it cannot be instantiated.  Instead, each concrete type of <code>Gate</code> is a struct which is a subtype of <code>AbstractGate</code>. Each descendant of <code>AbstractGate</code> must have at least the following fields:</p><ul><li><code>target::Int</code>: the qubit number to which the <code>Gate</code> is applied. Some gates have multiple targets.</li><li><code>parameter::Real</code>: for parameterized gates, determines which operation is applied (e.g. rotation angles), i.e., is used in the construction of the matrix used in the application of its <code>Operator</code>.</li></ul><p><strong>Examples</strong></p><p>A struct must be defined for each new gate type, such as the following X_45 gate which applies a 45° rotation about the X axis:</p><pre><code class="language-julia-repl hljs">julia&gt; struct X45 &lt;: AbstractGate
           target::Int
       end;
</code></pre><p>For convenience, a constructor can be defined:</p><pre><code class="language-julia-repl hljs">julia&gt; x_45(target::Integer) = X45(target);
</code></pre><p>To simulate the effect of the gate in a <code>QuantumCircuit</code> or when applied to a <code>Ket</code>, the function <code>get_operator</code> must be extended.</p><pre><code class="language-julia-repl hljs">julia&gt; Qanuk.get_operator(gate::X45, T::Type{&lt;:Complex}=ComplexF64) = rotation_x(π/4, T);
</code></pre><p>The gate inverse can also be specified by extending the <code>inv</code> function.</p><pre><code class="language-julia-repl hljs">julia&gt; inv(gate::X45) = rotation_x(gate.target, -π/4);
</code></pre><p>An instance of the X_45 gate can now be created:</p><pre><code class="language-julia-repl hljs">julia&gt; x_45_gate = x_45(1)
Gate Object: X45
Connected_qubits	: [1]
Operator:
(2, 2)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
0.9238795325112867 + 0.0im    0.0 - 0.3826834323650898im
0.0 - 0.3826834323650898im    0.9238795325112867 + 0.0im


julia&gt; inv(x_45_gate)
Gate Object: Qanuk.RotationX
Parameters: 
theta	: -0.7853981633974483

Connected_qubits	: [1]
Operator:
(2, 2)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
0.9238795325112867 + 0.0im    -0.0 + 0.3826834323650898im
-0.0 + 0.3826834323650898im    0.9238795325112867 + 0.0im

</code></pre><p>To enable printout of a circuit containing our new gate type, a symbol  must be defined as follows.</p><pre><code class="language-julia-repl hljs">julia&gt; Qanuk.gates_display_symbols[X45]=[&quot;X45&quot;];
</code></pre><p>If this gate is to be sent as an instruction to a hardware QPU,  an instruction string must be defined.</p><pre><code class="language-julia-repl hljs">julia&gt; Qanuk.gates_instruction_symbols[X45]=&quot;x45&quot;;
</code></pre><p>A circuit containing this gate can now be constructed:</p><pre><code class="language-julia-repl hljs">julia&gt; circuit=QuantumCircuit(qubit_count=2,gates=[x_45_gate])
Quantum Circuit Object:
   qubit_count: 2
q[1]:──X45──

q[2]:───────</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.eye" href="#Qanuk.eye"><code>Qanuk.eye</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eye(),
eye(size::Integer)</code></pre><p>Return the identity matrix as a <code>DenseOperator</code>, which is defined as:</p><p class="math-container">\[I = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; 1
    \end{bmatrix}.\]</p><p>Calling eye(size) will produce an identity matrix <code>DenseOperator</code>  of dimensions (size,size).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; eye()
(2, 2)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im

julia&gt; eye(4)
(4, 4)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1002-L1035">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.identity_gate" href="#Qanuk.identity_gate"><code>Qanuk.identity_gate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">identity_gate(target)</code></pre><p>Return the Identity <code>Gate</code>, which applies the <a href="library.html#Qanuk.identity_gate"><code>identity_gate()</code></a> <code>IdentityOperator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1844-L1848">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.sigma_p" href="#Qanuk.sigma_p"><code>Qanuk.sigma_p</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_p()</code></pre><p>Return the spin-<span>$\frac{1}{2}$</span> raising <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_+ = \begin{bmatrix}
    0 &amp; 1 \\
    0 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L937-L947">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.sigma_m" href="#Qanuk.sigma_m"><code>Qanuk.sigma_m</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_m()</code></pre><p>Return the spin-<span>$\frac{1}{2}$</span> lowering <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_- = \begin{bmatrix}
    0 &amp; 0 \\
    1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L950-L960">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.sigma_x" href="#Qanuk.sigma_x"><code>Qanuk.sigma_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_x()</code></pre><p>Return the Pauli-X <code>AntiDiagonalOperator</code>, which is defined as:</p><p class="math-container">\[\sigma_x = \begin{bmatrix}
    0 &amp; 1 \\
    1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L898-L908">source</a></section><section><div><pre><code class="nohighlight hljs">sigma_x(target)</code></pre><p>Return the Pauli-X <code>Gate</code>, which applies the <a href="library.html#Qanuk.sigma_x"><code>sigma_x()</code></a> <code>AntiDiagonalOperator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1338-L1342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.sigma_y" href="#Qanuk.sigma_y"><code>Qanuk.sigma_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_y()</code></pre><p>Return the Pauli-Y <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_y = \begin{bmatrix}
    0 &amp; -i \\
    i &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L911-L921">source</a></section><section><div><pre><code class="nohighlight hljs">sigma_y(target)</code></pre><p>Return the Pauli-Y <code>Gate</code>, which applies the <a href="library.html#Qanuk.sigma_y"><code>sigma_y()</code></a> <code>Operator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1369-L1373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.sigma_z" href="#Qanuk.sigma_z"><code>Qanuk.sigma_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigma_z()</code></pre><p>Return the Pauli-Z <code>Operator</code>, which is defined as:</p><p class="math-container">\[\sigma_z = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; -1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L924-L934">source</a></section><section><div><pre><code class="nohighlight hljs">sigma_z(target)</code></pre><p>Return the Pauli-Z <code>Gate</code>, which applies the <a href="library.html#Qanuk.sigma_z"><code>sigma_z()</code></a> <code>Operator</code> to the target qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1383-L1387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.hadamard" href="#Qanuk.hadamard"><code>Qanuk.hadamard</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hadamard()</code></pre><p>Return the Hadamard <code>Operator</code>, which is defined as:</p><p class="math-container">\[H = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; 1 \\
    1 &amp; -1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L963-L973">source</a></section><section><div><pre><code class="nohighlight hljs">hadamard(target)</code></pre><p>Return the Hadamard <code>Gate</code>, which applies the <a href="library.html#Qanuk.hadamard"><code>hadamard()</code></a> <code>Operator</code> to the <code>target</code> qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1396-L1400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.pi_8" href="#Qanuk.pi_8"><code>Qanuk.pi_8</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pi_8()</code></pre><p>Return the <code>Operator</code> for the π/8 gate, which is defined as:</p><p class="math-container">\[T = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; e^{i\frac{\pi}{4}}
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L976-L986">source</a></section><section><div><pre><code class="nohighlight hljs">pi_8(target)</code></pre><p>Return a π/8 <code>Gate</code> (also known as a <span>$T$</span> <code>Gate</code>), which applies the <a href="library.html#Qanuk.pi_8"><code>pi_8()</code></a> <code>DiagonalOperator</code> to the <code>target</code> qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1409-L1413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.pi_8_dagger" href="#Qanuk.pi_8_dagger"><code>Qanuk.pi_8_dagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pi_8_dagger()</code></pre><p>Return the adjoint <code>DiagonalOperator</code> of the π/8 gate, which is defined as:</p><p class="math-container">\[T^\dagger = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; e^{-i\frac{\pi}{4}}
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L989-L999">source</a></section><section><div><pre><code class="nohighlight hljs">pi_8_dagger(target)</code></pre><p>Return an adjoint π/8 <code>Gate</code> (also known as a <span>$T^\dagger$</span> <code>Gate</code>), which applies the <a href="library.html#Qanuk.pi_8_dagger"><code>pi_8_dagger()</code></a> <code>Operator</code> to the <code>target</code> qubit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1425-L1429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.x_90" href="#Qanuk.x_90"><code>Qanuk.x_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x_90()</code></pre><p>Return the <code>Operator</code> which applies a π/2 rotation about the X axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_x\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; -i \\
    -i &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1041-L1053">source</a></section><section><div><pre><code class="nohighlight hljs">x_90(target)</code></pre><p>Return a <code>Gate</code> that applies a 90° rotation about the X axis as defined by the <a href="library.html#Qanuk.x_90"><code>x_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1441-L1445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.x_minus_90" href="#Qanuk.x_minus_90"><code>Qanuk.x_minus_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x_minus_90()</code></pre><p>Return the <code>Operator</code> which applies a -π/2 rotation about the X axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_x\left(-\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; i \\
    i &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1056-L1068">source</a></section><section><div><pre><code class="nohighlight hljs">x_minus_90(target)</code></pre><p>Return a <code>Gate</code> that applies a -90° rotation about the X axis as defined by the <a href="library.html#Qanuk.x_minus_90"><code>x_minus_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1456-L1460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.y_90" href="#Qanuk.y_90"><code>Qanuk.y_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y_90()</code></pre><p>Return the <code>Operator</code> which applies a π/2 rotation about the Y axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_y\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; -1 \\
    1 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1071-L1083">source</a></section><section><div><pre><code class="nohighlight hljs">y_90(target)</code></pre><p>Return a <code>Gate</code> that applies a 90° rotation about the Y axis as defined by the <a href="library.html#Qanuk.y_90"><code>y_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1471-L1475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.y_minus_90" href="#Qanuk.y_minus_90"><code>Qanuk.y_minus_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">y_minus_90()</code></pre><p>Return the <code>Operator</code> which applies a -π/2 rotation about the Y axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_y\left(-\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 &amp; 1 \\
    -1 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1086-L1098">source</a></section><section><div><pre><code class="nohighlight hljs">y_minus_90(target)</code></pre><p>Return a <code>Gate</code> that applies a -90° rotation about the Y axis as defined by the <a href="library.html#Qanuk.y_minus_90"><code>y_minus_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1486-L1490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.z_90" href="#Qanuk.z_90"><code>Qanuk.z_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">z_90()</code></pre><p>Return the <code>Operator</code> which applies a π/2 rotation about the Z axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_z\left(\frac{\pi}{2}\right) = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; i
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1101-L1113">source</a></section><section><div><pre><code class="nohighlight hljs">z_90(target)</code></pre><p>Return a <code>Gate</code> that applies a 90° rotation about the Z axis as defined by the <a href="library.html#Qanuk.z_90"><code>z_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1501-L1505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.z_minus_90" href="#Qanuk.z_minus_90"><code>Qanuk.z_minus_90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">z_minus_90()</code></pre><p>Return the <code>Operator</code> which applies a -π/2 rotation about the Z axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_z\left(-\frac{\pi}{2}\right) = \begin{bmatrix}
    1 &amp; 0 \\
    0 &amp; -i
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1116-L1128">source</a></section><section><div><pre><code class="nohighlight hljs">z_minus_90(target)</code></pre><p>Return a <code>Gate</code> that applies a -90° rotation about the Z axis as defined by the <a href="library.html#Qanuk.z_minus_90"><code>z_minus_90()</code></a> <code>Operator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1516-L1520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.rotation" href="#Qanuk.rotation"><code>Qanuk.rotation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation(theta, phi)</code></pre><p>Return the <code>Operator</code> which applies a rotation <code>theta</code> about the cos(<code>phi</code>)X+sin(<code>phi</code>)Y axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R(\theta, \phi) = \begin{bmatrix}
    \mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
        -i e^{-i\phi} \mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
    -i e^{i\phi} \mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
        \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1131-L1145">source</a></section><section><div><pre><code class="nohighlight hljs">rotation(target, theta, phi)</code></pre><p>Return a gate that applies a rotation <code>theta</code> to the <code>target</code> qubit about the cos(<code>phi</code>)X+sin(<code>phi</code>)Y axis.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Qanuk.rotation"><code>rotation(theta, phi)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1532-L1538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.rotation_x" href="#Qanuk.rotation_x"><code>Qanuk.rotation_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_x(theta)</code></pre><p>Return the <code>Operator</code> which applies a rotation <code>theta</code> about the X axis.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_x(\theta) = \begin{bmatrix}
\mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
    -i\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
-i\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
    \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1151-L1165">source</a></section><section><div><pre><code class="nohighlight hljs">rotation_x(target, theta)</code></pre><p>Return a <code>Gate</code> that applies a rotation <code>theta</code> about the X axis of the <code>target</code> qubit.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Qanuk.rotation_x"><code>rotation_x(theta)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1559-L1565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.rotation_y" href="#Qanuk.rotation_y"><code>Qanuk.rotation_y</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotation_y(theta)</code></pre><p>Return the <code>Operator</code> that applies a rotation <code>theta</code> about the Y axis of the <code>target</code> qubit.</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[R_y(\theta) = \begin{bmatrix}
\mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
    -\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
    \mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1168-L1182">source</a></section><section><div><pre><code class="nohighlight hljs">rotation_y(target, theta)</code></pre><p>Return a <code>Gate</code> that applies a rotation <code>theta</code> about the Y axis of the <code>target</code> qubit.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Qanuk.rotation_y"><code>rotation_y(theta)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1579-L1585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.phase_shift" href="#Qanuk.phase_shift"><code>Qanuk.phase_shift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase_shift(phi)</code></pre><p>Return the <code>DiagonalOperator</code> that applies a phase shift <code>phi</code>.</p><p>The <code>DiagonalOperator</code> is defined as:</p><p class="math-container">\[P(\phi) = \begin{bmatrix}
    1 &amp; 0 \\[0.5em]      
    0 &amp; e^{i\phi}
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1185-L1197">source</a></section><section><div><pre><code class="nohighlight hljs">phase_shift(target, phi)</code></pre><p>Return a <code>Gate</code> that applies a phase shift <code>phi</code> to the <code>target</code> qubit as defined by the <a href="library.html#Qanuk.phase_shift"><code>phase_shift(phi)</code></a> <code>DiagonalOperator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1599-L1603">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.universal" href="#Qanuk.universal"><code>Qanuk.universal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">universal(theta, phi, lambda)</code></pre><p>Return the <code>Operator</code> which performs a rotation about the angles <code>theta</code>, <code>phi</code>, and <code>lambda</code>. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU</p><p>The <code>Operator</code> is defined as:</p><p class="math-container">\[U(\theta, \phi, \lambda) = \begin{bmatrix}
    \mathrm{cos}\left(\frac{\theta}{2}\right) &amp;
        -e^{i\lambda}\mathrm{sin}\left(\frac{\theta}{2}\right) \\[0.5em]      
    e^{i\phi}\mathrm{sin}\left(\frac{\theta}{2}\right) &amp;
        e^{i\left(\phi+\lambda\right)}\mathrm{cos}\left(\frac{\theta}{2}\right)
\end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1200-L1215">source</a></section><section><div><pre><code class="nohighlight hljs">universal(target, theta, phi, lambda)</code></pre><p>Return a gate which rotates the <code>target</code> qubit given the angles <code>theta</code>, <code>phi</code>, and <code>lambda</code>. See: https://qiskit.org/textbook/ch-states/single-qubit-gates.html#generalU</p><p>The corresponding <code>Operator</code> is <a href="library.html#Qanuk.universal"><code>universal(theta, phi, lambda)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1617-L1624">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.control_z" href="#Qanuk.control_z"><code>Qanuk.control_z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">control_z()</code></pre><p>Return the controlled-Z <code>Operator</code>, which is defined as:</p><p class="math-container">\[CZ = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; -1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1243-L1255">source</a></section><section><div><pre><code class="nohighlight hljs">control_z(control_qubit, target_qubit)</code></pre><p>Return a controlled-Z gate given a <code>control_qubit</code> and a <code>target_qubit</code>.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Qanuk.control_z"><code>control_z()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1647-L1653">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.control_x" href="#Qanuk.control_x"><code>Qanuk.control_x</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">control_x()</code></pre><p>Return the controlled-X (or controlled NOT) <code>Operator</code>, which is defined as:</p><p class="math-container">\[CX = CNOT = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1221-L1233">source</a></section><section><div><pre><code class="nohighlight hljs">control_x(control_qubit, target_qubit)</code></pre><p>Return a controlled-X gate (also known as a controlled NOT gate) given a <code>control_qubit</code> and a <code>target_qubit</code>.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Qanuk.control_x"><code>control_x()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1692-L1698">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.iswap" href="#Qanuk.iswap"><code>Qanuk.iswap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswap()</code></pre><p>Return the imaginary swap <code>Operator</code>, which is defined as:</p><p class="math-container">\[iSWAP = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; i &amp; 0 \\
    0 &amp; i &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1265-L1277">source</a></section><section><div><pre><code class="nohighlight hljs">iswap(qubit_1, qubit_2)</code></pre><p>Return the imaginary swap <code>Gate</code> which applies the imaginary swap <code>Operator</code> to <code>qubit_1</code> and <code>qubit_2.</code></p><p>The corresponding <code>Operator</code> is <a href="library.html#Qanuk.iswap"><code>iswap()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1717-L1723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.swap" href="#Qanuk.swap"><code>Qanuk.swap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swap()</code></pre><p>Return the swap <code>Operator</code>, which is defined as:</p><p class="math-container">\[iSWAP = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1280-L1292">source</a></section><section><div><pre><code class="nohighlight hljs">swap(qubit_1, qubit_2)</code></pre><p>Return the swap <code>Gate</code> which applies the swap <code>Operator</code> to <code>qubit_1</code> and <code>qubit_2.</code></p><p>The corresponding <code>Operator</code> is <a href="library.html#Qanuk.swap"><code>swap()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1740-L1746">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.toffoli" href="#Qanuk.toffoli"><code>Qanuk.toffoli</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">toffoli()</code></pre><p>Return the Toffoli <code>Operator</code>, which is defined as:</p><p class="math-container">\[CCX = CCNOT = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
    0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1295-L1311">source</a></section><section><div><pre><code class="nohighlight hljs">toffoli(control_qubit_1, control_qubit_2, target_qubit)</code></pre><p>Return a Toffoli gate (also known as a CCNOT gate) given two control qubits and a <code>target_qubit</code>.</p><p>The corresponding <code>Operator</code> is <a href="library.html#Qanuk.toffoli"><code>toffoli()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1761-L1767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.iswap_dagger" href="#Qanuk.iswap_dagger"><code>Qanuk.iswap_dagger</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iswap_dagger()</code></pre><p>Return the adjoint of the imaginary swap <code>Operator</code>, which is defined as:</p><p class="math-container">\[iSWAP^\dagger = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; -i &amp; 0 \\
    0 &amp; -i &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
    \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1323-L1335">source</a></section><section><div><pre><code class="nohighlight hljs">iswap_dagger(qubit_1, qubit_2)</code></pre><p>Return the adjoint imaginary swap <code>Gate</code> which applies the adjoint imaginary swap <code>Operator</code> to <code>qubit_1</code> and <code>qubit_2.</code></p><p>The corresponding <code>Operator</code> is <a href="library.html#Qanuk.iswap_dagger"><code>iswap_dagger()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1821-L1827">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{AbstractGate, Ket}" href="#Base.:*-Tuple{AbstractGate, Ket}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:*(M::AbstractGate, x::Ket)</code></pre><p>Return a <code>Ket</code> which results from applying <code>Gate</code> <code>M</code> to <code>Ket</code> <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = fock(0, 2)
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ_1 = sigma_x(1)*ψ_0
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1859-L1879">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.apply_gate!" href="#Qanuk.apply_gate!"><code>Qanuk.apply_gate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_gate!(state::Ket, gate::Gate)</code></pre><p>Update the <code>state</code> by applying a <code>gate</code> to it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = fock(0, 2)
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im


julia&gt; apply_gate!(ψ_0, sigma_x(1))

julia&gt; print(ψ_0)
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L286-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_operator" href="#Qanuk.get_operator"><code>Qanuk.get_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_operator(gate::Gate)</code></pre><p>Returns the <code>Operator</code> which is associated to a <code>Gate</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = sigma_x(1);

julia&gt; get_operator(x)
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1349-L1366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{AbstractGate}" href="#Base.inv-Tuple{AbstractGate}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(gate::AbstractGate)</code></pre><p>Return a <code>Gate</code> which is the inverse of the input <code>gate</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; u = universal(1, -pi/2, pi/3, pi/4)
Gate Object: Qanuk.Universal
Parameters: 
theta	: -1.5707963267948966
phi	: 1.0471975511965976
lambda	: 0.7853981633974483

Connected_qubits	: [1]
Operator:
(2, 2)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
0.7071067811865476 + 0.0im    0.5 + 0.4999999999999999im
-0.3535533905932738 - 0.6123724356957945im    -0.18301270189221924 + 0.6830127018922194im


julia&gt; inv(u)
Gate Object: Qanuk.Universal
Parameters: 
theta	: 1.5707963267948966
phi	: -0.7853981633974483
lambda	: -1.0471975511965976

Connected_qubits	: [1]
Operator:
(2, 2)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
0.7071067811865476 + 0.0im    -0.3535533905932738 + 0.6123724356957945im
0.5 - 0.4999999999999999im    -0.18301270189221924 - 0.6830127018922194im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L1888-L1926">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.is_gate_type" href="#Qanuk.is_gate_type"><code>Qanuk.is_gate_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_gate_type(gate::AbstractGate, type::Type)::Bool</code></pre><p>Determines if a <code>gate</code> is of the specified <code>type</code>.</p><div class="admonition is-warning"><header class="admonition-header">Use is_gate_type instead of isa!</header><div class="admonition-body"><p>For <code>AbstractGate</code> objects, <code>is_gate_type</code> should be used instead of <code>isa</code>. The utilization of <code>isa</code> could lead to unexpected behavior (e.g. if a gate has been moved).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gate = sigma_x(1)
Gate Object: Qanuk.SigmaX
Connected_qubits	: [1]
Operator:
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; is_gate_type(gate, Qanuk.SigmaX)
true

julia&gt; is_gate_type(gate, Qanuk.SigmaY)
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L104-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_gate_type" href="#Qanuk.get_gate_type"><code>Qanuk.get_gate_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_gate_type(gate::AbstractGate)::Type</code></pre><p>Returns the type of a <code>gate</code>.</p><div class="admonition is-warning"><header class="admonition-header">Use get_gate_type instead of typeof!</header><div class="admonition-body"><p>For <code>AbstractGate</code> objects, <code>get_gate_type</code> should be used instead of <code>typeof</code>. The utilization of <code>typeof</code> could lead to unexpected behavior (e.g. if a gate has been moved).</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gate = sigma_x(1)
Gate Object: Qanuk.SigmaX
Connected_qubits	: [1]
Operator:
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; get_gate_type(gate)
Qanuk.SigmaX
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L135-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.move_gate" href="#Qanuk.move_gate"><code>Qanuk.move_gate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">move_gate(gate::AbstractGate,
    qubit_mapping::AbstractDict{&lt;:Integer,&lt;:Integer})::AbstractGate</code></pre><p>Returns a copy of <code>gate</code> where the qubits on which the <code>gate</code> acts have been updated based on <code>qubit_mapping</code>.</p><p>The dictionary <code>qubit_mapping</code> contains key-value pairs describing how to update the target qubits. The key indicates which target qubit to change while the associated value specifies the new qubit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gate = sigma_x(1)
Gate Object: Qanuk.SigmaX
Connected_qubits	: [1]
Operator:
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; move_gate(gate, Dict(1=&gt;2))
Gate Object: Qanuk.SigmaX
Connected_qubits	: [2]
Operator:
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/quantum_gate.jl#L223-L257">source</a></section></article><h2 id="Quantum-Processing-Unit"><a class="docs-heading-anchor" href="#Quantum-Processing-Unit">Quantum Processing Unit</a><a id="Quantum-Processing-Unit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Processing-Unit" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Qanuk.AnyonQPU" href="#Qanuk.AnyonQPU"><code>Qanuk.AnyonQPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnyonQPU</code></pre><p>A data structure to represent a Anyon System&#39;s QPU.  </p><p><strong>Fields</strong></p><ul><li><code>client                  ::Client</code> – Client to the QPU server.</li><li><code>status_request_throttle ::Function</code> – Used to rate-limit job status requests.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt;  qpu = AnyonQPU(host=&quot;example.anyonsys.com&quot;,user=&quot;test_user&quot;,access_token=&quot;not_a_real_access_token&quot;)
Quantum Processing Unit:
   manufacturer:  Anyon Systems Inc.
   generation:    Yukon
   serial_number: ANYK202201
   qubit_count:   6 
   connectivity_type:  linear</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/anyon/anyon.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.VirtualQPU" href="#Qanuk.VirtualQPU"><code>Qanuk.VirtualQPU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VirtualQPU</code></pre><p>A data structure to represent a Quantum Simulator.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=VirtualQPU()
Quantum Simulator:
   developers:  Anyon Systems Inc.
   package:     Qanuk.jl

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/anyon/qpu_interface.jl#L350-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.Client" href="#Qanuk.Client"><code>Qanuk.Client</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Client</code></pre><p>A data structure to represent a <em>Client</em> to a QPU service.  </p><p><strong>Fields</strong></p><ul><li><code>host::String</code> – URL of the QPU server.</li><li><code>user::String</code> – Username.</li><li><code>access_token::String</code> – User access token.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Client(host=&quot;http://example.anyonsys.com&quot;,user=&quot;test_user&quot;,access_token=&quot;not_a_real_access_token&quot;)
Client for QPU service:
   host:         http://example.anyonsys.com
   user:         test_user 
 
  </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/anyon/qpu_interface.jl#L154-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_host" href="#Qanuk.get_host"><code>Qanuk.get_host</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_host(Client)</code></pre><p>Returns host URL of a <code>Client</code> to a <code>QPU</code> service.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = Client(host=&quot;http://example.anyonsys.com&quot;,user=&quot;test_user&quot;,access_token=&quot;not_a_real_access_token&quot;);

julia&gt; get_host(c)
&quot;http://example.anyonsys.com&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/anyon/qpu_interface.jl#L186-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.submit_circuit" href="#Qanuk.submit_circuit"><code>Qanuk.submit_circuit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">submit_circuit(client::Client,circuit::QuantumCircuit,num_repetitions::Integer)</code></pre><p>Submit a circuit to a <code>Client</code> of <code>QPU</code> service, requesting a number of  repetitions (num_repetitions). Returns circuitID.  </p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)
&quot;8050e1ed-5e4c-4089-ab53-cccda1658cd0&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/anyon/qpu_interface.jl#L204-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_status" href="#Qanuk.get_status"><code>Qanuk.get_status</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_status(client::Client,circuitID::String)::Dict{String, String}</code></pre><p>Obtain the status of a circuit computation through a <code>Client</code> of a <code>QPU</code> service. Returns status::Dict containing status[&quot;type&quot;]:      -&quot;queued&quot;   : Computation in queue.     -&quot;running&quot;  : Computation being processed.     -&quot;failed&quot;   : QPU service has returned an error message.     -&quot;succeeded&quot;: Computation is completed, result is available.</p><p>In the case of status[&quot;type&quot;]==&quot;failed&quot;, the server error is contained in status[&quot;message&quot;].</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)
&quot;8050e1ed-5e4c-4089-ab53-cccda1658cd0&quot;

julia&gt; get_status(client,circuitID)
Status: succeeded
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/anyon/qpu_interface.jl#L237-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_result" href="#Qanuk.get_result"><code>Qanuk.get_result</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_result(client::Client,circuit::String)::Dict{String, Int}</code></pre><p>Get the histogram of a completed circuit calculation, through a <code>Client</code> of a <code>QPU</code> service,  by circuit identifier circuitID.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuitID=submit_circuit(client,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]),100)
&quot;8050e1ed-5e4c-4089-ab53-cccda1658cd0&quot;

julia&gt; get_status(client,circuitID);

julia&gt; get_result(client,circuitID)
Dict{String, Int64} with 1 entry:
  &quot;001&quot; =&gt; 100
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/anyon/qpu_interface.jl#L287-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.run_job" href="#Qanuk.run_job"><code>Qanuk.run_job</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run_job(qpu::VirtualQPU, circuit::QuantumCircuit,num_repetitions::Integer)</code></pre><p>Run a circuit computation on a <code>QPU</code> simulator, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=VirtualQPU();

julia&gt; run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)
Dict{String, Int64} with 1 entry:
  &quot;001&quot; =&gt; 100
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/anyon/qpu_interface.jl#L434-L450">source</a></section><section><div><pre><code class="nohighlight hljs">run_job(qpu::AnyonQPU, circuit::QuantumCircuit, num_repetitions::Integer)</code></pre><p>Run a circuit computation on a <code>QPU</code> service, repeatedly for the specified number of repetitions (num_repetitions).</p><p>Returns the histogram of the completed circuit calculations, or an error message.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=AnyonQPU(client);

julia&gt; run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)
Dict{String, Int64} with 1 entry:
  &quot;001&quot; =&gt; 100
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/anyon/anyon.jl#L150-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.transpile_and_run_job" href="#Qanuk.transpile_and_run_job"><code>Qanuk.transpile_and_run_job</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transpile_and_run_job(qpu::VirtualQPU, circuit::QuantumCircuit,num_repetitions::Integer;transpiler::Transpiler=get_transpiler(qpu))</code></pre><p>This method first transpiles the input circuit using either the default transpiler,  or any other transpiler passed as a key-word argument.   The transpiled circuit is then run on a <code>QPU</code> simulator, repeatedly for the specified  number of repetitions (num_repetitions). Returns the histogram of the  completed circuit calculations, or an error message.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=VirtualQPU();

julia&gt; transpile_and_run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)
Dict{String, Int64} with 1 entry:
  &quot;001&quot; =&gt; 100
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/anyon/qpu_interface.jl#L401-L419">source</a></section><section><div><pre><code class="nohighlight hljs">transpile_and_run_job(qpu::AnyonQPU, circuit::QuantumCircuit,num_repetitions::Integer;transpiler::Transpiler=get_transpiler(qpu))</code></pre><p>This method first transpiles the input circuit using either the default transpiler, or any other transpiler passed as a key-word argument. The transpiled circuit is then run on the AnyonQPU, repeatedly for the specified number of repetitions (num_repetitions).</p><p>Returns the histogram of the completed circuit calculations, or an error message.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=AnyonQPU(client_anyon);

julia&gt; transpile_and_run_job(qpu,QuantumCircuit(qubit_count=3,gates=[sigma_x(3),control_z(2,1)]) ,100)
Dict{String, Int64} with 1 entry:
  &quot;001&quot; =&gt; 100
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/anyon/anyon.jl#L109-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_transpiler" href="#Qanuk.get_transpiler"><code>Qanuk.get_transpiler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_transpiler(qpu::AnyonQPU)::Transpiler</code></pre><p>Returns the transpiler associated with this QPU.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; qpu=AnyonQPU(client);

julia&gt; get_transpiler(qpu)
SequentialTranspiler(Transpiler[CastToffoliToCXGateTranspiler(), CastCXToCZGateTranspiler(), CastISwapToCZGateTranspiler(), SwapQubitsForLineConnectivityTranspiler(), CastSwapToCZGateTranspiler(), CompressSingleQubitGatesTranspiler(), SimplifyTrivialGatesTranspiler(1.0e-6), CastUniversalToRzRxRzTranspiler(), SimplifyRxGatesTranspiler(1.0e-6), CastRxToRzAndHalfRotationXTranspiler(), CompressRzGatesTranspiler(), SimplifyRzGatesTranspiler(1.0e-6)])
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/anyon/anyon.jl#L209-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.SequentialTranspiler" href="#Qanuk.SequentialTranspiler"><code>Qanuk.SequentialTranspiler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SequentialTranspiler(Vector{&lt;:Transpiler})</code></pre><p>Composite transpiler object which is constructed from an array  of <code>Transpiler</code><code>stages. Calling</code>transpile(::SequentialTranspiler,::QuantumCircuit)<code>will apply each stage in sequence to the input circuit, and return a transpiled output circuit. The result of the input and output  circuit on any arbitrary state</code>Ket` is unchanged (up to a global phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; transpiler=SequentialTranspiler([CompressSingleQubitGatesTranspiler(),CastToPhaseShiftAndHalfRotationXTranspiler()]);

julia&gt; circuit = QuantumCircuit(qubit_count = 2, gates=[sigma_x(1),hadamard(1)])
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X────H──
               
q[2]:──────────
               



julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──Z────X_90────Z_90────X_m90────Z──
                                                              
q[2]:───────────────────────────────────
                                                              



julia&gt; circuit = QuantumCircuit(qubit_count = 3, gates=[sigma_x(1),sigma_y(1),control_x(2,3),phase_shift(1,π/3)])
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──X────Y─────────P(1.0472)──  

q[2]:────────────*───────────────
                 |               
q[3]:────────────X───────────────
                                 



julia&gt; transpile(transpiler,circuit)
Quantum Circuit Object:
   qubit_count: 3 
q[1]:──P(-2.0944)───────
                        
q[2]:────────────────*──
                     |  
q[3]:────────────────X──
                        


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/transpile.jl#L6-L65">source</a></section></article><h2 id="Quantum-Toolkit"><a class="docs-heading-anchor" href="#Quantum-Toolkit">Quantum Toolkit</a><a id="Quantum-Toolkit-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Toolkit" title="Permalink"></a></h2><h3 id="Basic-Quantum-Objects"><a class="docs-heading-anchor" href="#Basic-Quantum-Objects">Basic Quantum Objects</a><a id="Basic-Quantum-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Quantum-Objects" title="Permalink"></a></h3><p>There are three basic quantum objects in Qanuk to simulate a quantum system. These objects are Ket, Bra, and AbstractOperator.</p><article class="docstring"><header><a class="docstring-binding" id="Qanuk.Ket" href="#Qanuk.Ket"><code>Qanuk.Ket</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Ket represents a <em>quantum wavefunction</em> and is mathematically equivalent to a column vector of complex values. The norm of a Ket should always be unity.  </p><p><strong>Examples</strong></p><p>Although NOT the preferred way, one can directly build a Ket object by passing a column vector as the initializer. </p><pre><code class="language-julia-repl hljs">julia&gt; using Qanuk

julia&gt; ψ = Ket([1.0; 0.0; 0.0])
3-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im

</code></pre><p>A better way to initialize a Ket is to use a pre-built basis such as the <code>fock</code> basis. See <a href="library.html#Qanuk.fock"><code>fock</code></a> for further information on this function. </p><pre><code class="language-julia-repl hljs">julia&gt; ψ = fock(2, 3)
3-element Ket{ComplexF64}:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.Bra" href="#Qanuk.Bra"><code>Qanuk.Bra</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a Bra (i.e. a row vector of complex values). A Bra is created as the complex conjugate of a Ket.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = fock(1, 3)
3-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; _ψ = Bra(ψ)
3-element Bra{ComplexF64}:
0.0 - 0.0im
1.0 - 0.0im
0.0 - 0.0im


julia&gt; _ψ * ψ    # A Bra times a Ket is a scalar
1.0 + 0.0im

julia&gt; ψ*_ψ     # A Ket times a Bra is an operator
(3, 3)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L106-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.DiagonalOperator" href="#Qanuk.DiagonalOperator"><code>Qanuk.DiagonalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a diagonal quantum <code>Operator</code> (i.e. a complex matrix, with non-zero elements all lying on the diagonal).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; z = DiagonalOperator([1.0,-1.0])
(2,2)-element Qanuk.DiagonalOperator:
Underlying data type: ComplexF64:
1.0 + 0.0im    .
.    -1.0 + 0.0im

julia&gt; z = DiagonalOperator([1.0+im,1.0,1.0,0.0-im])
(4,4)-element Qanuk.DiagonalOperator:
Underlying data type: ComplexF64:
1.0 + 1.0im    .    .    .
.    1.0 + 0.0im    .    .
.    .    1.0 + 0.0im    .
.    .    .    0.0 - 1.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L308-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.AntiDiagonalOperator" href="#Qanuk.AntiDiagonalOperator"><code>Qanuk.AntiDiagonalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a anti-diagonal quantum <code>Operator</code> (i.e. a complex matrix, with non-zero elements all lying on the cross-diagonal).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; AntiDiagonalOperator([1,2])
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    2.0 + 0.0im    .
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L351-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.DenseOperator" href="#Qanuk.DenseOperator"><code>Qanuk.DenseOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a quantum operator with a full (dense) matrix representation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; z = DenseOperator([1.0 0.0;0.0 -1.0])
(2, 2)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    -1.0 + 0.0im
</code></pre><p>Alternatively:</p><pre><code class="language-julia-repl hljs">julia&gt; z = rotation(π/2,-π/4)  
(2, 2)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
0.7071067811865476 + 0.0im    0.4999999999999999 - 0.5im
-0.4999999999999999 - 0.5im    0.7071067811865476 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L198-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.adjoint(x)</code></pre><p>Compute the adjoint (a.k.a. conjugate transpose) of a Ket, a Bra, or an Operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L401-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.is_hermitian" href="#Qanuk.is_hermitian"><code>Qanuk.is_hermitian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_hermitian(A::AbstractOperator)</code></pre><p>Determine if Operator <code>A</code> is Hermitian (i.e. self-adjoint).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = sigma_y()
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    0.0 - 1.0im
    0.0 + 1.0im    .


julia&gt; is_hermitian(Y)
true

julia&gt; P = sigma_p()
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    0.0 + 0.0im    .


julia&gt; is_hermitian(P)
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L417-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{AbstractOperator}" href="#Base.exp-Tuple{AbstractOperator}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(A::AbstractOperator)</code></pre><p>Compute the matrix exponential of <code>Operator</code> <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = sigma_x()
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; x_rotation_90_deg = exp(-im*π/4*X)
(2, 2)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
0.7071067811865475 + 0.0im    0.0 - 0.7071067811865475im
0.0 - 0.7071067811865475im    0.7071067811865475 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L531-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractOperator, Int64, Int64}" href="#Base.getindex-Tuple{AbstractOperator, Int64, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><p>getindex(A::AbstractOperator, i::Integer, j::Integer)</p><p>Access the element at row i and column j in the matrix corresponding to <code>Operator</code> <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = sigma_y()
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    0.0 - 1.0im
    0.0 + 1.0im    .


julia&gt; Y[1,1]
0.0 + 0.0im

julia&gt; Y[1,2]
0.0 - 1.0im

julia&gt; Y[2,1]
0.0 + 1.0im

julia&gt; Y[2,2]
0.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L277-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.expected_value-Tuple{AbstractOperator, Ket}" href="#Qanuk.expected_value-Tuple{AbstractOperator, Ket}"><code>Qanuk.expected_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expected_value(A::AbstractOperator, psi::Ket)</code></pre><p>Compute the expectation value ⟨<code>ψ</code>|<code>A</code>|<code>ψ</code>⟩ given Operator <code>A</code> and Ket |<code>ψ</code>⟩.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([0.0; 1.0])
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im


julia&gt; A = sigma_z()
(2,2)-element Qanuk.DiagonalOperator:
Underlying data type: ComplexF64:
1.0 + 0.0im    .
.    -1.0 + 0.0im


julia&gt; expected_value(A, ψ)
-1.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L617-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sparse" href="#SparseArrays.sparse"><code>SparseArrays.sparse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sparse(x::AbstractOperator)</code></pre><p>Returns a SparseOperator representation of x.</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; z = sparse(sigma_z()) (2, 2)-element Qanuk.SparseOperator: Underlying data ComplexF64:  1.0 + 0.0im        ⋅            ⋅       -1.0 + 0.0im</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L182-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.eigen" href="#LinearAlgebra.eigen"><code>LinearAlgebra.eigen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eigen(A::AbstractOperator)</code></pre><p>Compute the eigenvalue decomposition of Operator <code>A</code> and return an <code>Eigen</code> factorization object <code>F</code>. Eigenvalues are found in <code>F.values</code> while eigenvectors are found in the matrix <code>F.vectors</code>. Each column of this matrix corresponds to an eigenvector. The <code>i</code>th eigenvector is extracted by calling <code>F.vectors[:, i]</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X = sigma_x()
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .

julia&gt; F = eigen(X);

julia&gt; eigenvalues = F.values
2-element Vector{Float64}:
 -1.0
  1.0

julia&gt; eigenvector_1 = F.vectors[:, 1]
2-element Vector{ComplexF64}:
 -0.7071067811865475 + 0.0im
  0.7071067811865475 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L560-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.tr" href="#LinearAlgebra.tr"><code>LinearAlgebra.tr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tr(A::AbstractOperator)</code></pre><p>Compute the trace of Operator <code>A</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; I = eye()
(2, 2)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im


julia&gt; trace = tr(I)
2.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L594-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.kron" href="#Base.kron"><code>Base.kron</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kron(x, y)</code></pre><p>Compute the Kronecker product of two <a href="library.html#Qanuk.Ket"><code>Kets</code></a> or two  <a href="library.html#Qanuk.DenseOperator"><code>DenseOperator</code></a> , <a href="library.html#Qanuk.DiagonalOperator"><code>DiagonalOperator</code></a>, <a href="library.html#Qanuk.AntiDiagonalOperator"><code>AntiDiagonalOperator</code></a>. More details about the Kronecker product can be found <a href="https://en.wikipedia.org/wiki/Kronecker_product">here</a>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = Ket([0.0; 1.0])
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im


julia&gt; ψ_1 = Ket([1.0; 0.0])
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ_0_1 = kron(ψ_0, ψ_1)
4-element Ket{ComplexF64}:
0.0 + 0.0im
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; kron(sigma_x(), sigma_y())
(4, 4)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 - 1.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 1.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 - 1.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 1.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L659-L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.MultiBodySystem" href="#Qanuk.MultiBodySystem"><code>Qanuk.MultiBodySystem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure representing a quantum multi-body system.</p><p><strong>Fields</strong></p><ul><li><code>hilbert_space_structure</code> – a vector of integers specifying the local Hilbert space size for each &quot;body&quot; within the multi-body system. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L709-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.commute" href="#Qanuk.commute"><code>Qanuk.commute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">commute(A::AbstractOperator, B::AbstractOperator)</code></pre><p>Returns the commutation of <code>A</code> and <code>B</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; σ_x = sigma_x()
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; σ_y = sigma_y()
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    0.0 - 1.0im
    0.0 + 1.0im    .


julia&gt; commute(σ_x,σ_y)
(2,2)-element Qanuk.DiagonalOperator:
Underlying data type: ComplexF64:
0.0 + 2.0im    .
.    0.0 - 2.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1375-L1401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.anticommute" href="#Qanuk.anticommute"><code>Qanuk.anticommute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">anticommute(A::AbstractOperator, B::AbstractOperator)</code></pre><p>Returns the anticommutation of <code>A</code> and <code>B</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; σ_x = sigma_x()
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .


julia&gt; anticommute(σ_x,σ_x)
(2,2)-element Qanuk.DiagonalOperator:
Underlying data type: ComplexF64:
2.0 + 0.0im    .
.    2.0 + 0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1405-L1424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize!(x::Ket)</code></pre><p>Normalizes Ket <code>x</code> such that its magnitude becomes unity.</p><pre><code class="language-julia-repl hljs">julia&gt; ψ=Ket([1.,2.,4.])
3-element Ket{ComplexF64}:
1.0 + 0.0im
2.0 + 0.0im
4.0 + 0.0im

julia&gt; normalize!(ψ)
3-element Ket{ComplexF64}:
0.2182178902359924 + 0.0im
0.4364357804719848 + 0.0im
0.8728715609439696 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1196-L1215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T&lt;:Real" href="#Qanuk.get_measurement_probabilities-Union{Tuple{Ket{Complex{T}}}, Tuple{T}} where T&lt;:Real"><code>Qanuk.get_measurement_probabilities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_measurement_probabilities(x::Ket{Complex{T}},
    [target_bodies::Vector{U},
    hspace_size_per_body::Union{U,Vector{U}}=2])::AbstractVector{T}
    where {T&lt;:Real, U&lt;:Integer}</code></pre><p>Returns a vector listing the measurement probabilities of the <code>target_bodies</code> of <code>Ket</code> <code>x</code>.</p><p>The Hilbert space size per body can be specified by providing a <code>Vector</code> of <code>Integer</code> for the <code>hspace_size_per_body</code> argument. The <code>Vector</code> must specify the Hilbert space size for each body. If the space size is uniform, a single <code>Integer</code> can be given instead. If only <code>x</code> is provided, the probabilities are provided for all the bodies.</p><p>The measurement probabilities are listed from the smallest to the largest computational basis state. For instance, for a 2-qubit <code>Ket</code>, the probabilities are listed for 00, 01, 10, and 11.</p><p><strong>Examples</strong></p><p>The following example constructs a <code>Ket</code>, where the probability of measuring 00 is 50% and the probability of measuring 10 is also 50%.</p><pre><code class="language-julia-repl hljs">julia&gt; ψ = 1/sqrt(2)*Ket([1, 0, 1, 0])
4-element Ket{ComplexF64}:
0.7071067811865475 + 0.0im
0.0 + 0.0im
0.7071067811865475 + 0.0im
0.0 + 0.0im


julia&gt; get_measurement_probabilities(ψ)
4-element Vector{Float64}:
 0.4999999999999999
 0.0
 0.4999999999999999
 0.0
</code></pre><p>For the same <code>Ket</code>, the probability of measuring qubit 2 and finding 0 is 100%.</p><pre><code class="language-julia-repl hljs">julia&gt; target_qubit = [2];

julia&gt; get_measurement_probabilities(ψ, target_qubit)
2-element Vector{Float64}:
 0.9999999999999998
 0.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1222-L1269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.ket2dm" href="#Qanuk.ket2dm"><code>Qanuk.ket2dm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ket2dm(ψ::Ket)</code></pre><p>Returns the density matrix corresponding to the pure state ψ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1428-L1432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.fock_dm" href="#Qanuk.fock_dm"><code>Qanuk.fock_dm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fock_dm(i::Int64, hspace_size::Int64)</code></pre><p>Returns the density matrix corresponding to the Fock base <code>i</code> defined in a Hilbert space of size <code>hspace_size</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; dm=fock_dm(0,2)
(2, 2)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1437-L1452">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.wigner" href="#Qanuk.wigner"><code>Qanuk.wigner</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wigner(ρ::AbstractOperator, p::Real, q::Real)</code></pre><p>Computes the Wigner function of the density matrix <code>ρ</code> at the point (<code>p</code>,<code>q</code>).</p><pre><code class="language-julia-repl hljs">julia&gt; using Printf

julia&gt; alpha = 0.25;

julia&gt; hspace_size = 8;

julia&gt; Ψ = coherent(alpha, hspace_size);

julia&gt; prob = wigner(ket2dm(Ψ), 0, 0);

julia&gt; @printf &quot;prob: %.6f&quot; prob
prob: -0.561815</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1455-L1474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.moyal" href="#Qanuk.moyal"><code>Qanuk.moyal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moyal(m, n)</code></pre><p>Returns the Moyal function <code>w_mn(eta)</code> for Fock states <code>m</code> and <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1491-L1497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.genlaguerre" href="#Qanuk.genlaguerre"><code>Qanuk.genlaguerre</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">genlaguerre(x, alpha, n)</code></pre><p>Returns the generalized Laguerre polynomial of degree <code>n</code> for <code>x</code> using a recursive method. See <a href="https://en.wikipedia.org/wiki/Laguerre_polynomials">https://en.wikipedia.org/wiki/Laguerre_polynomials</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1505-L1510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_embed_operator" href="#Qanuk.get_embed_operator"><code>Qanuk.get_embed_operator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_embed_operator(op::DenseOperator, target_body_index::Int, system::MultiBodySystem)</code></pre><p>Uses a local operator (<code>op</code>), which is defined for a particular body (e.g. qubit) with index <code>target_body_index</code>, to build the corresponding operator for the Hilbert space of the multi-body system given by <code>system</code>. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; system = MultiBodySystem(3,2)
Qanuk.Multibody system with 3 bodies
   Hilbert space structure:
   [2, 2, 2]

julia&gt; x = sigma_x()
(2,2)-element Qanuk.AntiDiagonalOperator:
Underlying data type: ComplexF64:
    .    1.0 + 0.0im
    1.0 + 0.0im    .

julia&gt; X_1=get_embed_operator(x,1,system)
(8, 8)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L731-L762">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_num_qubits-Tuple{AbstractOperator}" href="#Qanuk.get_num_qubits-Tuple{AbstractOperator}"><code>Qanuk.get_num_qubits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_num_qubits(x::AbstractOperator)</code></pre><p>Returns the number of qubits associated with an <code>Operator</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = DenseOperator([1. 0.
                     0. 0.])
(2, 2)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im

julia&gt; get_num_qubits(ρ)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L912-L929">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_num_qubits-Tuple{Union{Bra, Ket}}" href="#Qanuk.get_num_qubits-Tuple{Union{Bra, Ket}}"><code>Qanuk.get_num_qubits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_num_qubits(x::Union{Ket, Bra})</code></pre><p>Returns the number of qubits associated with a <code>Ket</code> or a <code>Bra</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([1., 0., 0., 0.])
4-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; get_num_qubits(ψ)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L943-L961">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_num_bodies" href="#Qanuk.get_num_bodies"><code>Qanuk.get_num_bodies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_bodies(x::AbstractOperator, hilbert_space_size_per_body=2)</code></pre><p>Returns the number of bodies associated with an <code>Operator</code> given the <code>hilbert_space_size_per_body</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ρ = DenseOperator([1. 0. 0.
                     0. 0. 0.
                     0. 0. 0.])
(3, 3)-element Qanuk.DenseOperator:
Underlying data ComplexF64:
1.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im
0.0 + 0.0im    0.0 + 0.0im    0.0 + 0.0im

julia&gt; get_num_bodies(ρ, 3)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L971-L991">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_num_bodies" href="#Qanuk.get_num_bodies"><code>Qanuk.get_num_bodies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_num_bodies(x::Union{Ket, Bra}, hilbert_space_size_per_body=2)</code></pre><p>Returns the number of bodies associated with a <code>Ket</code> or a <code>Bra</code> given the <code>hilbert_space_size_per_body</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = Ket([1., 0., 0., 0., 0., 0., 0., 0., 0.])
9-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; get_num_bodies(ψ, 3)
2
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1005-L1029">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.fock" href="#Qanuk.fock"><code>Qanuk.fock</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fock(i, hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the <code>i</code>th Fock basis of a Hilbert space with size <code>hspace_size</code> as a Ket.</p><p>The Ket contains values of type <code>T</code>, which by default is ComplexF64.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = fock(0, 3)
3-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ = fock(1, 3)
3-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im
0.0 + 0.0im


julia&gt; ψ = fock(1, 3,ComplexF32) # specifying a type other than ComplexF64
3-element Ket{ComplexF32}:
0.0f0 + 0.0f0im
1.0f0 + 0.0f0im
0.0f0 + 0.0f0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1039-L1067">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.spin_up" href="#Qanuk.spin_up"><code>Qanuk.spin_up</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spin_up(T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the <code>Ket</code> representation of the spin-up state.</p><p>The <code>Ket</code> stores values of type <code>T</code>, which is <code>ComplexF64</code> by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = spin_up()
2-element Ket{ComplexF64}:
1.0 + 0.0im
0.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1074-L1090">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.spin_down" href="#Qanuk.spin_down"><code>Qanuk.spin_down</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spin_down(T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the <code>Ket</code> representation of the spin-down state.</p><p>The <code>Ket</code> stores values of type <code>T</code>, which is <code>ComplexF64</code> by default.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ = spin_down()
2-element Ket{ComplexF64}:
0.0 + 0.0im
1.0 + 0.0im

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1093-L1109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.create" href="#Qanuk.create"><code>Qanuk.create</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create(hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the bosonic creation operator for a Fock space of size <code>hspace_size</code>, of default type ComplexF64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1112-L1116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.destroy" href="#Qanuk.destroy"><code>Qanuk.destroy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">destroy(hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the bosonic annhilation operator for a Fock space of size <code>hspace_size</code>, of default type ComplexF64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1125-L1129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.number_op" href="#Qanuk.number_op"><code>Qanuk.number_op</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">number_op(hspace_size,T::Type{&lt;:Complex}=ComplexF64)</code></pre><p>Returns the number operator for a Fock space of size <code>hspace_size</code>, of default type ComplexF64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1138-L1142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.coherent" href="#Qanuk.coherent"><code>Qanuk.coherent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coherent(alpha, hspace_size)</code></pre><p>Returns a coherent state for the parameter <code>alpha</code> in a Fock space of size <code>hspace_size</code>. Note that |alpha|^2 is equal to the photon number of the coherent state. </p><pre><code class="nohighlight hljs"># Examples</code></pre><pre><code class="language-julia-repl hljs">julia&gt; ψ = coherent(2.0,20)
20-element Ket{ComplexF64}:
0.1353352832366127 + 0.0im
0.2706705664732254 + 0.0im
0.3827859860416437 + 0.0im
0.44200318416631873 + 0.0im
0.44200318416631873 + 0.0im
0.3953396664268989 + 0.0im
0.3227934859426707 + 0.0im
0.24400893961026582 + 0.0im
0.17254037586855772 + 0.0im
0.11502691724570517 + 0.0im
0.07274941014482605 + 0.0im
0.043869544940011405 + 0.0im
0.025328093580341972 + 0.0im
0.014049498479026656 + 0.0im
0.007509772823502764 + 0.0im
0.003878030010563634 + 0.0im
0.001939015005281817 + 0.0im
0.000940560432521708 + 0.0im
0.0004433844399679012 + 0.0im
0.00020343873336404819 + 0.0im


julia&gt; expected_value(number_op(20),ψ)
3.99999979364864 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L1151-L1186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.ShrodingerProblem" href="#Qanuk.ShrodingerProblem"><code>Qanuk.ShrodingerProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShrodingerProblem is a structure that is defined to solve the shrodinger equation in time-domain using sesolve().</code></pre><p><strong>Fields</strong></p><ul><li><code>H</code> – a function that retrurns the  Hamiltonian operator (of any subtype of <code>AbstractOperator</code>) as a function of time.</li><li><code>init_state</code> – initital state (<code>Ket</code>) of a quantum system</li><li><code>tspan</code> – time interval for which the system has to be simulated.        For instance:            tspan=(0.0,1.0) evaluates the output from t=0.0 to t=1.0</li><li><code>e_ops</code> – list of operators for which the expected value    (the observables) will be evaluated at each time step in t_range. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/dynamic_system.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.LindbladProblem" href="#Qanuk.LindbladProblem"><code>Qanuk.LindbladProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">A LindbladProblem is a structure that is defined to solve the Lindblad master equation in time-domain using lindblad_solve().</code></pre><p><strong>Fields</strong></p><ul><li><p><code>H</code> – a function that retrurns the  Hamiltonian operator (of any subtype of <code>AbstractOperator</code>) as a function of time.</p></li><li><p><code>init_state</code> – initital state density matrix (<code>DenseOperator</code>) of a quantum system</p></li><li><p><code>tspan</code> – time interval for which the system has to be simulated.        For instance:            tspan=(0.0,1.0) evaluates the output from t=0.0 to t=1.0</p></li><li><p><code>e_ops</code> – list of operators (type DenseOperator) for which the expected value    (the observables) will be evaluated at each time step in t_range. </p></li><li><p><code>c_ops</code> – list of collapse operators (type DenseOperator). </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/dynamic_system.jl#L22-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.sesolve" href="#Qanuk.sesolve"><code>Qanuk.sesolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sesolve(problem::ShrodingerProblem; kwargs...)</code></pre><p>Solves the Shrodinger equation:</p><p><span>$\frac{d \Psi}{d t}=-i \hat{H}\Psi$</span></p><p>and returns a tuple correponding the time instance vector, the corresponding wavefunction Ket, and a Vector of observables evaluated at each time step. </p><p><strong>Fields</strong></p><ul><li><code>problem</code> – An object of type ShrodingerProblem that defines the problem to be solved. </li><li><code>is_hamiltonian_static</code> – A Bool variable indicating whether the Hamiltonian operator changes with time or not. Default value is false. If true, the solver can have significant performance boost.</li><li><code>kwargs</code> – list of keyword arguments to be passed to the ODE solver. See (https://docs.sciml.ai/DiffEqDocs/stable/basics/common<em>solver</em>opts/#solver_options).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/dynamic_system.jl#L44-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.lindblad_solve" href="#Qanuk.lindblad_solve"><code>Qanuk.lindblad_solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    lindblad_solve(problem::LindbladProblem;kwargs...)</code></pre><p>Solves the Lindblad Master equation:</p><p><span>$\dot{\rho}=-i [H, \rho]+\sum_i \gamma_i\left(L_i \rho L^{\dag}_i - \frac{1}{2}\left\{L^{\dag}_i L_i, \rho\right\}\right)$</span></p><p>and returns a Vector of observables evaluated at each time step.</p><p><strong>Fields</strong></p><ul><li><code>problem</code> – An object of type LindbladProblem that defines the problem to be solved. </li><li><code>kwargs</code> – list of keyword arguments to be passed to the ODE solver. See (https://docs.sciml.ai/DiffEqDocs/stable/basics/common<em>solver</em>opts/#solver_options)..</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/dynamic_system.jl#L91-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.compare_kets" href="#Qanuk.compare_kets"><code>Qanuk.compare_kets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compare_kets(ψ_0::Ket,ψ_1::Ket)</code></pre><p>Checks for equivalence allowing for a global phase difference between two input kets.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ψ_0 = Ket([1.,2.,3.,4.])
4-element Ket{ComplexF64}:
1.0 + 0.0im
2.0 + 0.0im
3.0 + 0.0im
4.0 + 0.0im


julia&gt; δ=π/3 # phase offset
1.0471975511965976

julia&gt; ψ_1 = exp(im*δ)*ψ_0
4-element Ket{ComplexF64}:
0.5000000000000001 + 0.8660254037844386im
1.0000000000000002 + 1.7320508075688772im
1.5000000000000004 + 2.598076211353316im
2.0000000000000004 + 3.4641016151377544im


julia&gt; compare_kets(ψ_0,ψ_1)
true

julia&gt; apply_gate!(ψ_1,sigma_x(1))

julia&gt; compare_kets(ψ_0,ψ_1) # no longer equivalent after SigmaX gate
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/qobj.jl#L52-L88">source</a></section></article><h3 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h3><p>The <a href="https://github.com/anyonlabs/QanukPlots.jl">QanukPlots</a> package provides multiple visualization tools for Qanuk.jl. Please see the documentation of <a href="https://github.com/anyonlabs/QanukPlots.jl">QanukPlots</a> for more details. </p><h2 id="Pauli-Simulator"><a class="docs-heading-anchor" href="#Pauli-Simulator">Pauli Simulator</a><a id="Pauli-Simulator-1"></a><a class="docs-heading-anchor-permalink" href="#Pauli-Simulator" title="Permalink"></a></h2><p>Qanuk provides tools for the efficient storage and manipulation of Pauli group elements.</p><article class="docstring"><header><a class="docstring-binding" id="Qanuk.PauliGroupElement" href="#Qanuk.PauliGroupElement"><code>Qanuk.PauliGroupElement</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PauliGroupElement</code></pre><p>A Pauli group element which is represented using the approach of <a href="https://doi.org/10.1103/PhysRevA.68.042318">Dehaene and De Moor (2003)</a>.</p><p>The <a href="library.html#Qanuk.get_pauli"><code>get_pauli</code></a> functions should be used to generate <code>PauliGroupElement</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/pauli.jl#L7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_pauli" href="#Qanuk.get_pauli"><code>Qanuk.get_pauli</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_pauli(circuit::QuantumCircuit; imaginary_exponent::Integer=0,
    negative_exponent::Integer=0)::PauliGroupElement</code></pre><p>Returns a <code>PauliGroupElement</code> given a <code>circuit</code> containing Pauli gates.</p><p>A Pauli group element corresponds to <span>$i^\delta (-1)^\epsilon \sigma_a$</span>, where <span>$\delta$</span> and <span>$\epsilon$</span> are set by specifying <code>imaginary_exponent</code> and <code>negative_exponent</code>, respectively. The exponents must be 0 or 1. Their default value is 0. As for <span>$\sigma_a$</span>, it is a tensor product of Pauli operators. The Pauli operators are specified in the <code>circuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count=2);

julia&gt; push!(circuit, sigma_x(1), sigma_y(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X───────
               
q[2]:───────Y──
               



julia&gt; get_pauli(circuit, imaginary_exponent=1, negative_exponent=1)
Pauli Group Element:
-1.0im*X(1)*Y(2)


</code></pre><p>If multiple Pauli gates are applied to the same qubit in the <code>circuit</code>, the gates are multiplied with the first gate in the <code>circuit</code> being the rightmost gate in the multiplication.</p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count=1);

julia&gt; push!(circuit, sigma_x(1), sigma_z(1))
Quantum Circuit Object:
   qubit_count: 1 
q[1]:──X────Z──
               



julia&gt; get_pauli(circuit)
Pauli Group Element:
1.0im*Y(1)


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/pauli.jl#L21-L77">source</a></section><section><div><pre><code class="nohighlight hljs">get_pauli(gate::AbstractGate, num_qubits::Integer; imaginary_exponent::Integer=0,
    negative_exponent::Integer=0)::PauliGroupElement</code></pre><p>Returns a <code>PauliGroupElement</code> given a <code>gate</code> and the number of qubits.</p><p>A Pauli group element corresponds to <span>$i^\delta (-1)^\epsilon \sigma_a$</span>, where <span>$\delta$</span> and <span>$\epsilon$</span> are set by specifying <code>imaginary_exponent</code> and <code>negative_exponent</code>, respectively. The exponents must be 0 or 1. Their default value is 0. As for <span>$\sigma_a$</span>, it is a tensor product of Pauli operators. In this variant of the <code>get_pauli</code> function, a single Pauli operator is set by providing a <code>gate</code>. The number of qubits is specified by <code>num_qubits</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gate = sigma_x(2);

julia&gt; num_qubits = 3;

julia&gt; get_pauli(gate, num_qubits)
Pauli Group Element:
1.0*X(2)


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/pauli.jl#L104-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Qanuk.PauliGroupElement, Qanuk.PauliGroupElement}" href="#Base.:*-Tuple{Qanuk.PauliGroupElement, Qanuk.PauliGroupElement}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:*(p1::PauliGroupElement, p2::PauliGroupElement)::PauliGroupElement</code></pre><p>Returns the product of two <code>PauliGroupElement</code> objects.</p><p>The <code>PauliGroupElement</code> objects must be associated with the same number of qubits.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pauli_z = get_pauli(sigma_z(1), 1)
Pauli Group Element:
1.0*Z(1)



julia&gt; pauli_y = get_pauli(sigma_y(1), 1)
Pauli Group Element:
1.0*Y(1)



julia&gt; pauli_z*pauli_y
Pauli Group Element:
-1.0im*X(1)


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/pauli.jl#L179-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_quantum_circuit" href="#Qanuk.get_quantum_circuit"><code>Qanuk.get_quantum_circuit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_quantum_circuit(pauli::PauliGroupElement)::QuantumCircuit</code></pre><p>Returns the Pauli gates of a <code>PauliGroupElement</code> as a <code>QuantumCircuit</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; circuit = QuantumCircuit(qubit_count=2);

julia&gt; push!(circuit, sigma_x(1), sigma_y(2))
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X───────
               
q[2]:───────Y──
               



julia&gt; pauli = get_pauli(circuit, imaginary_exponent=1, negative_exponent=1)
Pauli Group Element:
-1.0im*X(1)*Y(2)



julia&gt; get_quantum_circuit(pauli)
Quantum Circuit Object:
   qubit_count: 2 
q[1]:──X───────
               
q[2]:───────Y──
               


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/pauli.jl#L271-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_negative_exponent" href="#Qanuk.get_negative_exponent"><code>Qanuk.get_negative_exponent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_negative_exponent(pauli::PauliGroupElement)::Int</code></pre><p>Returns the negative exponent of a <code>PauliGroupElement</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gate = sigma_x(2);

julia&gt; num_qubits = 3;

julia&gt; pauli = get_pauli(gate, num_qubits, negative_exponent=1)
Pauli Group Element:
-1.0*X(2)



julia&gt; get_negative_exponent(pauli)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/pauli.jl#L313-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Qanuk.get_imaginary_exponent" href="#Qanuk.get_imaginary_exponent"><code>Qanuk.get_imaginary_exponent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_imaginary_exponent(pauli::PauliGroupElement)::Int</code></pre><p>Returns the imaginary exponent of a <code>PauliGroupElement</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gate = sigma_x(2);

julia&gt; num_qubits = 3;

julia&gt; pauli = get_pauli(gate, num_qubits, imaginary_exponent=1)
Pauli Group Element:
1.0im*X(2)



julia&gt; get_imaginary_exponent(pauli)
1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anyonlabs/Qanuk.jl/blob/cb47f8ea9a6adfc7fbf4f9b8d2846b8cd799b009/src/core/pauli.jl#L340-L361">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="tutorials/run_circuit.html">« Run a circuit</a><a class="docs-footer-nextpage" href="development.html">Developing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 6 June 2023 22:23">Tuesday 6 June 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
